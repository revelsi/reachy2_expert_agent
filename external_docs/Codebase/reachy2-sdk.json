[
  {
    "page_content": "Example of how to draw a square with Reachy's right arm.",
    "metadata": {
      "source": "draw_square.py",
      "type": "module_docstring"
    }
  },
  {
    "page_content": "Build a 4x4 pose matrix for a given position in 3D space, with the effector at a fixed orientation.\n\nArgs:\n    x: The x-coordinate of the position.\n    y: The y-coordinate of the position.\n    z: The z-coordinate of the position.\n\nReturns:\n    A 4x4 NumPy array representing the pose matrix.",
    "metadata": {
      "source": "draw_square.py",
      "type": "function_docstring",
      "function": "build_pose_matrix",
      "class": null
    }
  },
  {
    "page_content": "def build_pose_matrix(x: float, y: float, z: float) -> npt.NDArray[np.float64]:\n    \"\"\"Build a 4x4 pose matrix for a given position in 3D space, with the effector at a fixed orientation.\n\n    Args:\n        x: The x-coordinate of the position.\n        y: The y-coordinate of the position.\n        z: The z-coordinate of the position.\n\n    Returns:\n        A 4x4 NumPy array representing the pose matrix.\n    \"\"\"\n    # The effector is always at the same orientation in the world frame\n    return np.array(\n        [\n            [0, 0, -1, x],\n            [0, 1, 0, y],\n            [1, 0, 0, z],\n            [0, 0, 0, 1],\n        ]\n    )",
    "metadata": {
      "source": "draw_square.py",
      "type": "function_definition",
      "function": "build_pose_matrix",
      "class": null
    }
  },
  {
    "page_content": "Draw a square path with Reachy's right arm in 3D space.\n\nThis function commands Reachy's right arm to move in a square pattern\nusing four predefined positions (A, B, C, and D) in the world frame.\nThe square is drawn by moving the arm sequentially through these positions:\n- A: (0.4, -0.5, -0.2)\n- B: (0.4, -0.5, 0)\n- C: (0.4, -0.3, 0)\n- D: (0.4, -0.3, -0.2)\n\nsee https://pollen-robotics.github.io/reachy2-docs/developing-with-reachy-2/basics/4-use-arm-kinematics/\nfor Reachy's coordinate system\n\nEach movement uses inverse kinematics to calculate the required joint\npositions to achieve the target pose and then sends the commands to\nReachy's arm to execute the movements.\n\nArgs:\n    reachy: An instance of the ReachySDK used to control the robot.",
    "metadata": {
      "source": "draw_square.py",
      "type": "function_docstring",
      "function": "draw_square",
      "class": null
    }
  },
  {
    "page_content": "def draw_square(reachy: ReachySDK) -> None:\n    \"\"\"Draw a square path with Reachy's right arm in 3D space.\n\n    This function commands Reachy's right arm to move in a square pattern\n    using four predefined positions (A, B, C, and D) in the world frame.\n    The square is drawn by moving the arm sequentially through these positions:\n    - A: (0.4, -0.5, -0.2)\n    - B: (0.4, -0.5, 0)\n    - C: (0.4, -0.3, 0)\n    - D: (0.4, -0.3, -0.2)\n\n    see https://pollen-robotics.github.io/reachy2-docs/developing-with-reachy-2/basics/4-use-arm-kinematics/\n    for Reachy's coordinate system\n\n    Each movement uses inverse kinematics to calculate the required joint\n    positions to achieve the target pose and then sends the commands to\n    Reachy's arm to execute the movements.\n\n    Args:\n        reachy: An instance of the ReachySDK used to control the robot.\n    \"\"\"\n    # Going from A to B\n    target_pose = build_pose_matrix(0.4, -0.5, 0)\n    ik = reachy.r_arm.inverse_kinematics(target_pose)\n    reachy.r_arm.goto(ik, duration=2.0, degrees=True)\n\n    current_pos = reachy.r_arm.forward_kinematics()\n    print(\"Pose B: \", current_pos)\n\n    # Going from B to C\n    target_pose = build_pose_matrix(0.4, -0.3, 0)\n    ik = reachy.r_arm.inverse_kinematics(target_pose)\n    reachy.r_arm.goto(ik, duration=2.0, degrees=True)\n\n    current_pos = reachy.r_arm.forward_kinematics()\n    print(\"Pose C: \", current_pos)\n\n    # Going from C to D\n    target_pose = build_pose_matrix(0.4, -0.3, -0.2)\n    ik = reachy.r_arm.inverse_kinematics(target_pose)\n    reachy.r_arm.goto(ik, duration=2.0, degrees=True)\n\n    current_pos = reachy.r_arm.forward_kinematics()\n    print(\"Pose D: \", current_pos)\n\n    # Going from D to A\n    target_pose = build_pose_matrix(0.4, -0.5, -0.2)\n    ik = reachy.r_arm.inverse_kinematics(target_pose)\n    reachy.r_arm.goto(ik, duration=2.0, degrees=True, wait=True)\n\n    current_pos = reachy.r_arm.forward_kinematics()\n    print(\"Pose A: \", current_pos)",
    "metadata": {
      "source": "draw_square.py",
      "type": "function_definition",
      "function": "draw_square",
      "class": null
    }
  },
  {
    "page_content": "Move Reachy's right arm to Point A in 3D space.\n\nThis function commands Reachy's right arm to move to a specified target position\n(Point A) in the world frame, which is located at (0.4, -0.5, -0.2).\n\nArgs:\n    reachy: An instance of the ReachySDK used to control the robot.",
    "metadata": {
      "source": "draw_square.py",
      "type": "function_docstring",
      "function": "goto_to_point_A",
      "class": null
    }
  },
  {
    "page_content": "def goto_to_point_A(reachy: ReachySDK) -> None:\n    \"\"\"Move Reachy's right arm to Point A in 3D space.\n\n    This function commands Reachy's right arm to move to a specified target position\n    (Point A) in the world frame, which is located at (0.4, -0.5, -0.2).\n\n    Args:\n        reachy: An instance of the ReachySDK used to control the robot.\n    \"\"\"\n    # position of point A in space\n    target_pose = build_pose_matrix(0.4, -0.5, -0.2)\n    # get the position in the joint space\n    joints_positions = reachy.r_arm.inverse_kinematics(target_pose)\n    # move Reachy's right arm to this point\n    reachy.r_arm.goto(joints_positions, duration=2, wait=True)",
    "metadata": {
      "source": "draw_square.py",
      "type": "function_definition",
      "function": "goto_to_point_A",
      "class": null
    }
  },
  {
    "page_content": "# Arm and Gripper",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 1,
      "section": "Arm and Gripper"
    }
  },
  {
    "page_content": "In the previous tutorial, we explored the concept of *goto* and basic control. Now, let's delve deeper into what we can do with Reachy's arms and grippers.",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 2,
      "section": "Arm and Gripper"
    }
  },
  {
    "page_content": "## Initialize Your Robot",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 3,
      "section": "Initialize Your Robot"
    }
  },
  {
    "page_content": "First, connect to your robot:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 4,
      "section": "Initialize Your Robot"
    }
  },
  {
    "page_content": "from reachy2_sdk import ReachySDK\nimport time\n\nreachy = ReachySDK(host='localhost')  # Replace with the actual IP adress of your robot",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 5,
      "section": "Initialize Your Robot"
    }
  },
  {
    "page_content": "Next, we need to turn on the parts we want to use:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 6,
      "section": "Initialize Your Robot"
    }
  },
  {
    "page_content": "reachy.l_arm.turn_on()\nreachy.r_arm.turn_on()",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 7,
      "section": "Initialize Your Robot"
    }
  },
  {
    "page_content": "Since the grippers are part of the arms, they will also be turned on. You could, of course, turn on the whole robot by calling `reachy.turn_on()` directly.\nLet's check if the arms are on:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 8,
      "section": "Initialize Your Robot"
    }
  },
  {
    "page_content": "print(reachy.r_arm.is_on())\nprint(reachy.l_arm.is_on())",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 9,
      "section": "Initialize Your Robot"
    }
  },
  {
    "page_content": "## Control the arms\n\nArms can be controlled in two spaces:\n\n* the **joint space**, which allows to read and write directly the angle values of each joint of the arm\n* the **cartesian space**, which consists in controlling the end effector position and orientation in Reachy's coordinate system\n\n> Both spaces are quite different, and **we advise not to mix them** if you are not familiar with the output.\nIn fact, values of the joint space are expressed in each actuator's coordinate system (respectively shoulder, elbow and wrist), whereas commands in cartesian space are expressed in Reachy's coordinate system",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 10,
      "section": "Control the arms"
    }
  },
  {
    "page_content": "### Joint space",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 11,
      "section": "Joint space"
    }
  },
  {
    "page_content": "Reachy's arm offers 7 degrees of freedom. It also gives access to one joint for the gripper.\nThe arm is divided as follow:\n- shoulder, composed of 2 joints (pitch and roll)\n- elbow, composed of 2 joints (yaw and pitch)\n- wrist, composed of 3 joints (roll, pitch and yaw)\n\nWe refer to the shoulder, elbow and wrist as actuators.\nFor some actions, such as changing the compliancy, it is the lowest level of control you will have.\n\nYou can inspect the details of the arm with:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 12,
      "section": "Joint space"
    }
  },
  {
    "page_content": "reachy.r_arm.joints",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 13,
      "section": "Joint space"
    }
  },
  {
    "page_content": "reachy.l_arm.joints",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 14,
      "section": "Joint space"
    }
  },
  {
    "page_content": "You can easily access the position of each joint in one call with `get_current_positions()`.",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 15,
      "section": "Joint space"
    }
  },
  {
    "page_content": "reachy.r_arm.get_current_positions()",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 16,
      "section": "Joint space"
    }
  },
  {
    "page_content": "reachy.l_arm.get_current_positions()",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 17,
      "section": "Joint space"
    }
  },
  {
    "page_content": "#### Move the arms in joint space",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 18,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "The simplest way to move an arm is to set the angle of each joint. Define a joint positions list:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 19,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "r_elbow_at_90_deg = [0, 10, -15, -90, 0, 0, -5]\nl_elbow_at_90_deg = [0, -10, 15, -90, 0, 0, 5]",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 20,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "Send the joint goal positions to the arm with `goto()`",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 21,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "reachy.r_arm.goto(r_elbow_at_90_deg)\nreachy.l_arm.goto(l_elbow_at_90_deg, wait = True)",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 22,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "In order to easily move a single joint, we can use the `goto()` method on a given joint:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 23,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "reachy.r_arm.elbow.pitch.goto(0)",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 24,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "This method works exactly like a goto on the part. All gotos sent to joints are stacked on the part they belong to.\nFor example:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 25,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "part_goto_id = reachy.r_arm.goto([0, 10, -15, -90, 0, 0, -5])\njoint_goto_id = reachy.r_arm.elbow.pitch.goto(0)\n\nprint(part_goto_id)\nprint(joint_goto_id)\n\nprint(reachy.r_arm.get_goto_queue())",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 26,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "`reachy.r_arm.elbow.pitch.goto(0)` command is stacked in r_arm gotos queue.\nThe goto on the elbow will be played when the previous command sent using `goto()` will be over.",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 27,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "The arms should have moved in a way similar to what we saw in the [goto tutorial](2_goto_introduction.ipynb). You already know that you can specify the duration or the interpolation mode of this kind of movement.\n\nWe've only seen movements expressed in the 'joint space', i.e., defined by a set of angles. How can we know the position of the gripper in space, or how can we reach an object for which we know its position? That's where kinematics come in.",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 28,
      "section": "Move the arms in joint space"
    }
  },
  {
    "page_content": "### Kinematics",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 29,
      "section": "Kinematics"
    }
  },
  {
    "page_content": "The kinematic model describes the motion of a robot in mathematical form without considering the forces and torque affecting it. It only focuses on the geometric relationship between elements.\n\nWe have defined the whole kinematic model of the arm. This means the translation and rotation required to go from one joint to the next one. \n\n[Long story](https://pollen-robotics.github.io/reachy2-docs/developing-with-reachy-2/basics/4-use-arm-kinematics/) short, there are two types of kinematics:\n- Forward kinematics: from the joints position, the gripper position is computed in cartesian space\n- Inverse kinematics: from a given gripper position to reach, all joints positions are computed in joint space\n\n> You can easily use forward kinematics and inverse kinematics to switch respectively from joint space to cartesian space and from cartesian space to joint space.",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 30,
      "section": "Kinematics"
    }
  },
  {
    "page_content": "#### Forward Kinematics",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 31,
      "section": "Forward Kinematics"
    }
  },
  {
    "page_content": "Each arm has a `forward_kinematics` method that computes a 4x4 pose matrix (position and orientation of the gripper in space). For instance, the previous movement left the left elbow at 90\u00b0. The position (x, y, z) of the gripper is:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 32,
      "section": "Forward Kinematics"
    }
  },
  {
    "page_content": "reachy.l_arm.forward_kinematics()[:3, 3]",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 33,
      "section": "Forward Kinematics"
    }
  },
  {
    "page_content": "It is not mandatory to move the arm to compute forward kinematics. This can be done for any set of joint positions such as:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 34,
      "section": "Forward Kinematics"
    }
  },
  {
    "page_content": "reachy.l_arm.forward_kinematics([10, 0, 0, -90, 0, 0, 0])",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 35,
      "section": "Forward Kinematics"
    }
  },
  {
    "page_content": "Reachy didn't move, but you know where it would have gone with an additional 10\u00b0 applied to the shoulder joint.",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 36,
      "section": "Forward Kinematics"
    }
  },
  {
    "page_content": "#### Inverse Kinematics",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 37,
      "section": "Inverse Kinematics"
    }
  },
  {
    "page_content": "Inverse kinematics works in the opposite way. Let's say you want to reach an object for which you know its position. What would be the set of joint positions to provide to `goto`?",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 38,
      "section": "Inverse Kinematics"
    }
  },
  {
    "page_content": "import numpy as np\ntarget = np.identity(4)\ntarget = np.array([[0, 0, -1, 0.3],\n    [0, 1, 0, 0.1],\n    [1, 0, 0, -0.3],\n    [0, 0, 0, 1]])",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 39,
      "section": "Inverse Kinematics"
    }
  },
  {
    "page_content": "joints_positions = reachy.l_arm.inverse_kinematics(target)\njoints_positions",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 40,
      "section": "Inverse Kinematics"
    }
  },
  {
    "page_content": "reachy.l_arm.goto(joints_positions)",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 41,
      "section": "Inverse Kinematics"
    }
  },
  {
    "page_content": "reachy.l_arm.goto_posture(\"default\")\nreachy.l_arm.goto(target, wait = True)",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 42,
      "section": "Inverse Kinematics"
    }
  },
  {
    "page_content": "> All these goto are illustrated in [draw_square](draw_square.py). Check it out to see how to make Reachy draw a square with its right arm!",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 43,
      "section": "Inverse Kinematics"
    }
  },
  {
    "page_content": "### Cartesian space",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 44,
      "section": "Cartesian space"
    }
  },
  {
    "page_content": "Controlling the arm in cartesian space allows you to control the position of the gripper in Reachy's coordinate system. It is the recommended way to control the robot for grasping goals.  \nLet's got back to the *elbow_90* pose:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 45,
      "section": "Cartesian space"
    }
  },
  {
    "page_content": "reachy.l_arm.goto_posture('elbow_90', wait = True)",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 46,
      "section": "Cartesian space"
    }
  },
  {
    "page_content": "You can easily access the current pose of the gripper using the previously seen method `forward_kinematics()`",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 47,
      "section": "Cartesian space"
    }
  },
  {
    "page_content": "current_pose = reachy.l_arm.forward_kinematics()\nprint(current_pose)",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 48,
      "section": "Cartesian space"
    }
  },
  {
    "page_content": "#### Move the arms in cartesian space",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 49,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "To control the arm in cartesian space, use the `goto(...)` method.  \nLet's use it on the current_pose:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 50,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "reachy.l_arm.goto(current_pose)",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 51,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "As you have just seen, the arm moved meanwhile the gripper is in the exact same position and orientation: that's because the computed inverse kinematics solution is different from the joints we decided to choose in joint space (`goto_posture()` is in fact a joint space method).  \n\nLet's send the arm to a new goal pose.  \nWe need to define a pose 4x4 matrix as the new goal pose for the gripper:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 52,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "new_pose = current_pose.copy()\nnew_pose[0, 3] += 0.1\nprint(new_pose)",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 53,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "This new_pose is translated 10cm front in Reachy's coordinate system (+10cm on Reachy's x axis).  \nYou can send it to the robot:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 54,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "reachy.l_arm.goto(new_pose)",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 55,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "To simplify your life, you have access to functions to easily compute translation or rotation.  \nUse the `translate_by(...)` method to send the gripper back to the previous pose, asking for a translation 10cm back (-10cm on Reachy's x axis):",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 56,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "reachy.l_arm.translate_by(-0.1, 0, 0, frame='robot')",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 57,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "You can easily make the gripper rotate with the `rotate_by(...)` method:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 58,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "reachy.l_arm.rotate_by(10, 0, 0, frame='gripper')",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 59,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "The gripper rotate by 10 degrees around the x axis of the gripper.  \nFor both functions, you need to specify a frame:\n* setting **gripper** as frame will translate or rotate in the gripper coordinate system\n* setting **robot** as frame will translate or rotate directly in Reachy's coordinate system",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 60,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "If you want to compute a translation or rotation without making the robot move, you can call `get_translation_by(...)` and `get_rotation_by(...)` to get the corresponding pose 4x4 matrix:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 61,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "reachy.l_arm.get_translation_by(-0.1, 0.2, -0.1, frame='gripper')",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 62,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "reachy.l_arm.get_rotation_by(-10, 20, 0, frame='gripper')",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 63,
      "section": "Move the arms in cartesian space"
    }
  },
  {
    "page_content": "## Gripper Control",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 64,
      "section": "Gripper Control"
    }
  },
  {
    "page_content": "Finally, you may want to open or close a gripper to grab an object! Use the `close` or `open` method to do so:\n> Those methods can't be set as blocking moves for now, so you need to add a waiting condition while the gripper is still moving. ",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 65,
      "section": "Gripper Control"
    }
  },
  {
    "page_content": "reachy.l_arm.gripper.close()\nwhile reachy.l_arm.gripper.is_moving():\n    time.sleep(0.1)\nreachy.l_arm.gripper.open()",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 66,
      "section": "Gripper Control"
    }
  },
  {
    "page_content": "Of course, you can partially open the gripper, and get its current opening:",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 67,
      "section": "Gripper Control"
    }
  },
  {
    "page_content": "reachy.l_arm.gripper.set_opening(55)\nwhile reachy.l_arm.gripper.is_moving():\n    time.sleep(0.1)\nreachy.l_arm.gripper.get_current_opening()",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 68,
      "section": "Gripper Control"
    }
  },
  {
    "page_content": "# Set robot back to compliant mode",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_markdown",
      "cell_number": 69,
      "section": "Set robot back to compliant mode"
    }
  },
  {
    "page_content": "reachy.goto_posture('default', duration = 2, wait = True)\n    \nreachy.turn_off_smoothly()",
    "metadata": {
      "source": "3_arm_and_gripper.ipynb",
      "type": "notebook_code",
      "cell_number": 70,
      "section": "Set robot back to compliant mode"
    }
  },
  {
    "page_content": "# Make some noise",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 1,
      "section": "Make some noise"
    }
  },
  {
    "page_content": "Reachy 2 has two microphones located on each antenna and one speaker inside its torso. The audio API allows you to record and play audio files.\n\n***Note that, for now, the audio files are located in a temporary folder on Reachy's computer and are deleted at each reboot of the robot. The file management is very basic, allowing just a list of files in a single folder.***",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 2,
      "section": "Make some noise"
    }
  },
  {
    "page_content": "## Manage the sound files",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 3,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "First, connect to your robot.  ",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 4,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "from reachy2_sdk import ReachySDK\n\nreachy = ReachySDK(host='localhost')  # Replace with the actual IP",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 5,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "You can first check the audio files available on Reachy.",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 6,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "reachy.audio.get_audio_files()",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 7,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "The list may be empty if you have just started to play with Reachy. Let's add a new audio file. Reachy is able to play wav, mp3, and ogg files. Ogg files can be downloaded [here for instance](https://getsamplefiles.com/sample-audio-files/ogg).\nMake sure to change the path name in the line below. For instance */home/name/Downloads/sample-1.ogg* or *C:\\Users\\name\\Downloads\\sample-1.ogg*",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 8,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "reachy.audio.upload_audio_file('<path>/sample-1.ogg')\nreachy.audio.upload_audio_file('<path>/sample-4.ogg')",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 9,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "Now these two files should be listed on Reachy:",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 10,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "reachy.audio.get_audio_files()",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 11,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "A file can be removed if you don't want to use it. It should no longer be in the list!",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 12,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "reachy.audio.remove_audio_file('sample-4.ogg')",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 13,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "reachy.audio.get_audio_files()",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 14,
      "section": "Manage the sound files"
    }
  },
  {
    "page_content": "### Play a sound\n\nOnce an audio file is uploaded onto Reachy, you can play it",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 15,
      "section": "Play a sound"
    }
  },
  {
    "page_content": "reachy.audio.play_audio_file('sample-1.ogg')",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 16,
      "section": "Play a sound"
    }
  },
  {
    "page_content": "Stop the playback whenever you want",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 17,
      "section": "Play a sound"
    }
  },
  {
    "page_content": "reachy.audio.stop_playing()",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 18,
      "section": "Play a sound"
    }
  },
  {
    "page_content": "### Record a sound\n\nIn a similar way, a sound can be recorded using Reachy's microphones. Only the ogg extension is allowed for now. The duration of the recording, in seconds, must be set.",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 19,
      "section": "Record a sound"
    }
  },
  {
    "page_content": "reachy.audio.record_audio('tutorial.ogg', duration_secs=5)",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 20,
      "section": "Record a sound"
    }
  },
  {
    "page_content": "The audio is recorded in the background; it may be stopped at any time.",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 21,
      "section": "Record a sound"
    }
  },
  {
    "page_content": "reachy.audio.stop_recording()",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 22,
      "section": "Record a sound"
    }
  },
  {
    "page_content": "The audio file is now on Reachy's file system, and available for listening",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 23,
      "section": "Record a sound"
    }
  },
  {
    "page_content": "reachy.audio.get_audio_files()",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 24,
      "section": "Record a sound"
    }
  },
  {
    "page_content": "reachy.audio.play_audio_file('tutorial.ogg')",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 25,
      "section": "Record a sound"
    }
  },
  {
    "page_content": "Finally, the audio file can be downloaded to your local machine.",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_markdown",
      "cell_number": 26,
      "section": "Record a sound"
    }
  },
  {
    "page_content": "reachy.audio.download_audio_file('tutorial.ogg', '<path>')",
    "metadata": {
      "source": "6_audio.ipynb",
      "type": "notebook_code",
      "cell_number": 27,
      "section": "Record a sound"
    }
  },
  {
    "page_content": "# Goto introduction",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 1,
      "section": "Goto introduction"
    }
  },
  {
    "page_content": "ReachySDK for Reachy 2 offers you methods to make movements with the arms and head, controlling the target position in several ways, choosing the duration of the movement, or even the interpolation mode. We called them **Goto**.\n\nThose methods work the same way on the arms and on the head, **but not on the mobile base**.\n\nThe methods to use in order to control the robot are:\n-  for the arms:  \n    - **`goto()`**: depending on the parameter entered, you can control either :\n        - the joint value of each joint in degrees : *list of 7 values (joint space)*\n        - the end-effector position in the robot frame of reference : *4x4 homogeneous matrix (cartesian space)*\n    - **`translate_by()`** and **`rotate_by()`** : you can translate or rotate the position of the end-effector in space, in robot frame or gripper frame\n\n- for the head:  \n    - **`goto()`**: depending on the parameter entered, you can control either :\n        - the joint value of each head joint in degrees : *list of  3 values (joint space)*\n        - the head orientation in the robot frame : *quaternion (cartesian space)*\n        > Be careful that, between the joint and cartesian spaces, there is a 10-degree difference in pitch : to have the head looking forward, in joint space you have to put rpy = [0,10,0] whereas in cartesian space, it's the equivalent of [0,0,0].\n    \n    - **`look_at()`**: you control the head by giving a point in the robot coordinate system the head will look at\n    - **`rotate_by()`**: you can rotate the head in relation to its current position, by setting roll, pitch and yaw values in degrees, either in relation to the robot's frame of reference or to the head.\n\n",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 2,
      "section": "Goto introduction"
    }
  },
  {
    "page_content": "## Initialize to your robot",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 3,
      "section": "Initialize to your robot"
    }
  },
  {
    "page_content": "Connect to your robot:",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 4,
      "section": "Initialize to your robot"
    }
  },
  {
    "page_content": "from reachy2_sdk import ReachySDK\nimport time # used for time.sleep() later in the tutorial\n\nreachy = ReachySDK(host='localhost')  #Replace localhost with your robot's IP address",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 5,
      "section": "Initialize to your robot"
    }
  },
  {
    "page_content": "Turn on Reachy so the motors can be controlled, and set in the default posture :",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 6,
      "section": "Initialize to your robot"
    }
  },
  {
    "page_content": "reachy.turn_on()\n\nreachy.goto_posture('default')",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 7,
      "section": "Initialize to your robot"
    }
  },
  {
    "page_content": "`goto_posture()` is a convenient function to configure the posture of all Reachy parts at once. \n\nIt accepts the parameters : \n- *default* (i.e. `goto_posture('default')`), which gives Reachy's default pose with arms outstretched on either side of the body,\n- *elbow_90* (i.e. `goto_posture('elbow_90')`), in which Reachy has the two forearms parallel to the ground. \n\nThese standard poses can be useful when you want to start a new task from a known position.",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 8,
      "section": "Initialize to your robot"
    }
  },
  {
    "page_content": "> This example is available in [set_default_posture.py](set_default_posture.py)",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 9,
      "section": "Initialize to your robot"
    }
  },
  {
    "page_content": "## Set your First Move",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 10,
      "section": "Set your First Move"
    }
  },
  {
    "page_content": "Let's move Reachy's right arm. The *goto* allows to control the 7 degrees of freedom of the arm at once (see [getting_started](1_getting_started.ipynb))",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 11,
      "section": "Set your First Move"
    }
  },
  {
    "page_content": "goto_1 = reachy.r_arm.goto([0, 10, -10, -90, 0, 0, 0])\n\nprint(f'goto 1 {goto_1}')",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 12,
      "section": "Set your First Move"
    }
  },
  {
    "page_content": "This method returns an id, that you can use to get information on this movement or to cancel this movement. Store this id in a variable (*goto_1* here) to be able to use it further. All the goto methods return an id.",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 13,
      "section": "Set your First Move"
    }
  },
  {
    "page_content": "## Goto commands",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 14,
      "section": "Goto commands"
    }
  },
  {
    "page_content": "A goto command can only be sent on parts:\n- reachy.l_arm\n- reachy.r_arm\n- reachy.head\n\nand is defined by 3 parameters : \n- the **joint commands**, as a list of articular degree values (7 for the arms and 3 for the head)\n- the **duration**, in seconds - *set to 2 by default*\n- the **interpolation mode**, 'linear' or 'minimum_jerk' - *set to 'minimum_jerk' by default*\n",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 15,
      "section": "Goto commands"
    }
  },
  {
    "page_content": "#### Goto duration \n\nYou can give a custom duration for the execution of the movements, as shown in the examples above : ",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 16,
      "section": "Goto duration"
    }
  },
  {
    "page_content": "reachy.head.goto([20, 20, -10], duration = 3)\nreachy.l_arm.goto([0, -10, 10, -90, 0, 0, 0], duration = 5)\n\n\n# Doing:\nreachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0])\n# will lead to the same result as:\nreachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], duration = 2)",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 17,
      "section": "Goto duration"
    }
  },
  {
    "page_content": "> Default duration is **2 seconds**.\n\nYou **cannot set a duration to 0 second**. This will raise an exception in your code!",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 18,
      "section": "Goto duration"
    }
  },
  {
    "page_content": "reachy.l_arm.goto([0, 0, 0, 0, 0, 0, 0], duration = 0) # raises an exception",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 19,
      "section": "Goto duration"
    }
  },
  {
    "page_content": "#### Goto interpolation mode",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 20,
      "section": "Goto interpolation mode"
    }
  },
  {
    "page_content": "The goto methods generates a trajectory between the present position and the goal position. This trajectory is then interpolated at a predefined frequency (100Hz) to compute all intermediary target positions that should be followed before reaching the final goal position. Depending on the interpolation mode chosen, you can have a better control over speed and acceleration.\n\nTwo interpolation modes are available when sending a goto command:\n- the **linear** interpolation mode\n- the **minimum-jerk** interpolation mode\n\nBoth trajectories start and finish at the same point but don't follow the same intermediate positions. The minimum jerk will slowly accelerate at the begining and slowly decelerate at the end. This makes the movements more natural.\n\nYou can specify the interpolation mode by setting the **`interpolation_mode`** argument when calling the method:",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 21,
      "section": "Goto interpolation mode"
    }
  },
  {
    "page_content": "reachy.goto_posture('default', wait = True)\nreachy.head.goto([20, 20, -10], interpolation_mode='linear')\nreachy.l_arm.goto([0, -10, 10, -90, 0, 0, 0], interpolation_mode='linear')",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 22,
      "section": "Goto interpolation mode"
    }
  },
  {
    "page_content": "> Default interpolation mode is **minimum_jerk**.",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 23,
      "section": "Goto interpolation mode"
    }
  },
  {
    "page_content": "# Doing:\nreachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0])\n# will lead to the same result as:\nreachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], interpolation_mode='minimum_jerk')\n",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 24,
      "section": "Goto interpolation mode"
    }
  },
  {
    "page_content": "## Goto execution",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 25,
      "section": "Goto execution"
    }
  },
  {
    "page_content": "There are two important concepts to be aware of : \n- gotos are stacked for a part (i.e. they run one after another),\n- but each part is independent (i.e. a goto for the left arm will run in parallel with a goto for the right arm).",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 26,
      "section": "Goto execution"
    }
  },
  {
    "page_content": "### Goto is non-blocking for other parts ",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 27,
      "section": "Goto is non-blocking for other parts"
    }
  },
  {
    "page_content": "It means you can send a goto command on different parts, it won't wait for the movement to be executed on the first part to execute the other one, but will follow the timing of your code.\n\nLet's take an example with a motion sequence : \n\n- Start by returning the robot to its neutral position.",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 28,
      "section": "Goto is non-blocking for other parts"
    }
  },
  {
    "page_content": "reachy.goto_posture('default')",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 29,
      "section": "Goto is non-blocking for other parts"
    }
  },
  {
    "page_content": "- Send a goto on both arms, with a delay between them. ",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 30,
      "section": "Goto is non-blocking for other parts"
    }
  },
  {
    "page_content": "reachy.l_arm.goto([0, 0, 10, -90, 0, 0, 15], duration = 3)\ntime.sleep(1)\nreachy.r_arm.goto([0, 0, -10, -90, 0, 0, -15], duration = 2)",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 31,
      "section": "Goto is non-blocking for other parts"
    }
  },
  {
    "page_content": "This sequence will take 3 seconds to execute, as the right arm will start its movement 1 second after the left arm has started its own movement. They will finish at the same time.",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 32,
      "section": "Goto is non-blocking for other parts"
    }
  },
  {
    "page_content": "### Goto is blocking and stacked for a part",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 33,
      "section": "Goto is blocking and stacked for a part"
    }
  },
  {
    "page_content": "It means that you can send several goto commands on a part one after another without any delay, they will be played in this order, but will wait for the previous goto to be finished.  \n\nLet's take an example with the following sequence:",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 34,
      "section": "Goto is blocking and stacked for a part"
    }
  },
  {
    "page_content": "reachy.goto_posture('default')\nreachy.l_arm.goto([0, 0, 15, -90, 0, 0, 15], duration = 3)\nreachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], duration = 2)\nreachy.l_arm.goto([0, 0, 15, -90, 0, 0, 15], duration = 3)",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 35,
      "section": "Goto is blocking and stacked for a part"
    }
  },
  {
    "page_content": "This sequence will take 8 seconds to execute, as each movement on the left arm will wait for the previous before starting.  \n\nNevertheless, you can still send goto commands to other parts.",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 36,
      "section": "Goto is blocking and stacked for a part"
    }
  },
  {
    "page_content": "reachy.goto_posture('default')\n\nreachy.l_arm.goto([0, 0, 15, -90, 0, 0, 15], duration = 3)  #1\ntime.sleep(1)\nreachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], duration = 2)  #2\nreachy.l_arm.goto([0, 0, 15, -90, 0, 0, 15], duration = 3)  #3\nreachy.r_arm.goto([0, 0, -15, -90, 0, 0, -15], duration = 2)  #4",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 37,
      "section": "Goto is blocking and stacked for a part"
    }
  },
  {
    "page_content": "This sequence will still take 8 seconds to execute:\n- commands #1, #2 and #3 are sent to the left arm. They will be stacked on the left arm, and the `time.sleep(1)` won't have any effect . When received, command #2 will simply wait 2 seconds rather than 3 secondes in the previous example.\n- commands #4 is sent on the right arm, where no movement is processed. It will then start 1 second after command #1 has started, and will then be over approximatively at the same time.\n\nThe sequence execution order is #1, #4, #2, #3.",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 38,
      "section": "Goto is blocking and stacked for a part"
    }
  },
  {
    "page_content": "So how can a left arm goto wait for a right arm move? That's simple using the parameter *wait* in goto functions ! \n\n### Wait parameter\n\nAs you could see earlier in the goto_posture() command, we can set the parameter *wait = True* in goto functions for the execution of the program to wait for the end of the movement before going on. \n",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 39,
      "section": "Goto is blocking and stacked for a part"
    }
  },
  {
    "page_content": "reachy.goto_posture('default', wait = True)\nprint('Default posture : done')\nr_goto_1 = reachy.r_arm.goto([0, 5, -15, -90, 0, 0, -10], duration = 2, wait = True)\nprint('Right move : done')\nr_goto_2 = reachy.l_arm.goto([0, -5, 15, -90, 0, 0, 10], duration = 2, wait = True)\nprint('Left move : done')\nreachy.goto_posture('default', wait = True)\nprint('Default posture : done')",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 40,
      "section": "Goto is blocking and stacked for a part"
    }
  },
  {
    "page_content": "### Goto state",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 41,
      "section": "Goto state"
    }
  },
  {
    "page_content": "For a specific goto, you may want to know its current state. You can get information on the goto given its id with 2 methods available at reachy's level:\n\n- **`is_goto_finished()`**: return True if the movement is over, but also if it won't be played because it has been cancelled for example\n- **`get_goto_joints_request()`**: will return the joints goal positions sent to the part by the corresponding goto command \n\n\nLet's take an example:",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 42,
      "section": "Goto state"
    }
  },
  {
    "page_content": "goto_1 = reachy.l_arm.goto([0, 0, 0, -60, 0, 0, 0], duration = 3)\n\ntime.sleep(1)\n\n# Goto is currently being played\ngoto1_is_finished = reachy.is_goto_finished(goto_1)\nprint(f'After 1 second, goto 1 is finished : {goto1_is_finished}\\n')\n\ntime.sleep(3)\n\n# Goto is now over\ngoto1_is_finished = reachy.is_goto_finished(goto_1)\nprint(f'After 4 seconds, goto 1 is finished : {goto1_is_finished}')",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 43,
      "section": "Goto state"
    }
  },
  {
    "page_content": "Retrieve the joint requests of a goto command from its ID:",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 44,
      "section": "Goto state"
    }
  },
  {
    "page_content": "reachy.get_goto_joints_request(goto_1)",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 45,
      "section": "Goto state"
    }
  },
  {
    "page_content": "You get information on the part involved, the target joint values, the duration of the movement, and the interpolation mode. ",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 46,
      "section": "Goto state"
    }
  },
  {
    "page_content": "### Part execution state",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 47,
      "section": "Part execution state"
    }
  },
  {
    "page_content": "As the sequence can become complex, you can get information for each part on its current status, to know which movement is being played and know which others are waiting to be played.  \nFor each part, the following methods are available:\n- **`get_goto_playing()`**: will return the id of the currently played goto on the part\n- **`get_goto_queue()`**: will return the ids of all stacked goto commands waiting to be played on the part\n\nThose methods are called at the part level, to get info on the state of the part.  \n\nLet's take an example. ",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 48,
      "section": "Part execution state"
    }
  },
  {
    "page_content": "# Write a sequence for the left arm\ngoto_1 = reachy.l_arm.goto([0, -15, 15, -90, 0, 0, 0], duration = 3)\ngoto_2 = reachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], duration = 2)\ngoto_3 = reachy.l_arm.goto([0, -15, 15, -90, 0, 0, 0], duration = 3)\n\nprint(f'goto 1: {goto_1.id}, goto 2: {goto_2.id}, goto 3: {goto_3.id}')\n\n# Goto #1 is currently playing\ncurrent_goto = reachy.l_arm.get_goto_playing()\nprint(f'current goto : {current_goto.id}')\nprint(f'l_arm queue length: {len(reachy.l_arm.get_goto_queue())} gotos waiting to be played.')",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 49,
      "section": "Part execution state"
    }
  },
  {
    "page_content": "## Goto cancellation",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 50,
      "section": "Goto cancellation"
    }
  },
  {
    "page_content": "If you want to modify the queue of goto commands on a part, or interrupt the movement being played, you can cancel goto commands at any time.  ",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 51,
      "section": "Goto cancellation"
    }
  },
  {
    "page_content": "### Single goto cancellation",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 52,
      "section": "Single goto cancellation"
    }
  },
  {
    "page_content": "To cancel a single movement, currently playing or stacked in a part's queue, use its id and call `cancel_goto_by_id()` from reachy. It will stop the robot at its current position.",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 53,
      "section": "Single goto cancellation"
    }
  },
  {
    "page_content": "reachy.goto_posture('default', wait = True)\ngoto_1 = reachy.l_arm.goto([0, 15, 15, -90, 10, 0, 0], duration = 3)\ngoto_2 = reachy.head.goto([30, 0, 0], duration = 3)\n\ntime.sleep(1)\nreachy.cancel_goto_by_id(goto_1)",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 54,
      "section": "Single goto cancellation"
    }
  },
  {
    "page_content": "### Multiple gotos cancellation",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 55,
      "section": "Multiple gotos cancellation"
    }
  },
  {
    "page_content": "To cancel all gotos at once, you can call the `cancel_all_goto()` methods.  \nThis method can be called at the level you want to act, which can be either **reachy** or a **specific part**. ",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 56,
      "section": "Multiple gotos cancellation"
    }
  },
  {
    "page_content": "#### All gotos",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 57,
      "section": "All gotos"
    }
  },
  {
    "page_content": "For example, if you want to cancel all gotos on all parts:",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 58,
      "section": "All gotos"
    }
  },
  {
    "page_content": "reachy.goto_posture('default', wait = True)\n\n# Send a sequence of gotos\nreachy.head.goto([20, 30, -10], duration = 3)\nreachy.l_arm.goto([0, 0, 0, -90, 0, 0, 0], duration = 3)\nreachy.l_arm.goto([0, 0, 0, 0, 0, 0, 0], duration = 3)\n\ntime.sleep(1.5)\n\n# Cancel all gotos\nreachy.cancel_all_goto()\n\nprint(f\"Length of l_arm goto queue : {len(reachy.l_arm.get_goto_queue())}\")",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 59,
      "section": "All gotos"
    }
  },
  {
    "page_content": "All movements are cancelled, even the movement stacked in the left arm queue which will never be played.  ",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 60,
      "section": "All gotos"
    }
  },
  {
    "page_content": "#### All gotos for one part",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 61,
      "section": "All gotos for one part"
    }
  },
  {
    "page_content": "If you only want to cancel movement on the left arm:",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 62,
      "section": "All gotos for one part"
    }
  },
  {
    "page_content": "reachy.goto_posture('default', wait = True)\n\n# Send a sequence of gotos\nreachy.head.goto([20, 30, -10], duration=3)\nreachy.l_arm.goto([0, 0, 0, -90, 0, 0, 0], duration = 3)\nreachy.l_arm.goto([0, 0, 0, 0, 0, 0, 0], duration = 2)\n\ntime.sleep(1)\n\n# Cancel gotos on left arm only\nreachy.l_arm.cancel_all_goto()",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 63,
      "section": "All gotos for one part"
    }
  },
  {
    "page_content": "The movement on the head will continue, but all the movements of the left will be stopped and the left arm queue cleaned.",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_markdown",
      "cell_number": 64,
      "section": "All gotos for one part"
    }
  },
  {
    "page_content": "reachy.goto_posture('default', wait=True)\nreachy.turn_off()",
    "metadata": {
      "source": "2_goto_introduction.ipynb",
      "type": "notebook_code",
      "cell_number": 65,
      "section": "All gotos for one part"
    }
  },
  {
    "page_content": "# Head control",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 1,
      "section": "Head control"
    }
  },
  {
    "page_content": "Reachy 2's head is mounted on an Orbita3D actuator, referred to as the **neck** actuator, giving 3 degrees of freedom to control the head orientation.  \n\nBefore starting to control the head, connect to your Reachy and turn it on.",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 2,
      "section": "Head control"
    }
  },
  {
    "page_content": "## Initialize your robot",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 3,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "First connect to your robot:",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 4,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "from reachy2_sdk import ReachySDK\n\nreachy = ReachySDK(host='localhost')  # Replace with the actual IP address",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 5,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "Let's check what contains the head part:",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 6,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "reachy.head.joints",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 7,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "As you can see, the head is composed of **three joints**:\n- neck.roll\n- neck.pitch\n- neck.yaw\n\nAll joints belong to the same Orbita3D actuator, referred to as the **neck**.\n\nTo start, we need to turn the head on:",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 8,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "reachy.head.turn_on()",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 9,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "You could of course turn on the whole robot by calling `reachy.turn_on()` directly.",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 10,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "## Head goto",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 11,
      "section": "Head goto"
    }
  },
  {
    "page_content": "There are several ways to control the head movements:\n- using the `look_at()`, `goto` and `rotate_by` methods, called directly at the **head** level. These methods work as in the [goto_introduction](2_goto_introduction.ipynb) example\n- controlling the joints goal positions, namely **reachy.head.neck.roll**, **reachy.head.neck.pitch** and **reachy.head.neck.yaw**.",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 12,
      "section": "Head goto"
    }
  },
  {
    "page_content": "### look_at()\n\nYou can use the `look_at()` function to make the head look at a specific point in space. This point must be given in Reachy 2's coordinate system in **meters**. The coordinate system is the one we have seen previously:\n\n* the X axis corresponds to the forward arrow,\n* the Y axis corresponds to the right to left arrow,\n* the Z axis corresponds to the up arrow.\n\nThe origin of this coordinate system is located in the upper part of the robot trunk.\n\nIf you want Reachy to look forward, you can send it the following.",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 13,
      "section": "look_at()"
    }
  },
  {
    "page_content": "reachy.head.look_at(x=0.5, y=0, z=0.2, duration=1.0, wait = True)",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 14,
      "section": "look_at()"
    }
  },
  {
    "page_content": "You can use multiple *look_at* to chain head movements, or even chain them with the `goto()` function described below. As seen in the goto tutorial, the commands on the head will be stacked.\nFor example:",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 15,
      "section": "look_at()"
    }
  },
  {
    "page_content": "import time\n\nlook_right = reachy.head.look_at(x=0.5, y=-0.3, z=0.1, duration=1.0)\nlook_down = reachy.head.look_at(x=0.5, y=0, z=-0.4, duration=1.0)\nlook_left = reachy.head.look_at(x=0.5, y=0.3, z=-0.1, duration=1.0)\nlook_front = reachy.head.look_at(x=0.5, y=0, z=0, duration=1.0)",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 16,
      "section": "look_at()"
    }
  },
  {
    "page_content": "The best way to understand how to use the *look_at* is to play with it. Picture a position you would like Reachy's head to be in, guess a point which could match for the *look_at* and check if you got it right!",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 17,
      "section": "look_at()"
    }
  },
  {
    "page_content": "### goto()\n\nThe `goto()` function is another way to control the head. There is two ways to use it :\n- from the desired orientation as a quaternion (in cartesian space)\n- from joints positions (in joint space)\n\nSo, you give either a quaternion or a list of 3 degree values.\n",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 18,
      "section": "goto()"
    }
  },
  {
    "page_content": "#### In cartesian space\n\nYou can control the head with a quaternion, in cartesian space.\n\nYou can use [pyquaternion library](https://kieranwynn.github.io/pyquaternion/) to create suitable quaternion for this method.",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 19,
      "section": "In cartesian space"
    }
  },
  {
    "page_content": "from pyquaternion import Quaternion\n\nq = Quaternion(axis=[1, 0, 0], angle=3.14159265 / 4) # tilt head about 45\u00b0 to the right\nreachy.head.goto(q)",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 20,
      "section": "In cartesian space"
    }
  },
  {
    "page_content": "#### In joint space\n\n You can directly control the joint value of the neck, giving the roll, pitch and yaw angles in degrees. The rotation is made in the order: roll, pitch, yaw, in the Orbita3D coordinate system.",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 21,
      "section": "In joint space"
    }
  },
  {
    "page_content": "reachy.head.goto([15, -20, 0], duration=1.0)",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 22,
      "section": "In joint space"
    }
  },
  {
    "page_content": "### Rotate_by()\n\nYou can also control the head from its current position, by using the *rotate_by* function and specifying angular degree values in roll, pitch, yaw, either in Reachy's or head's frame. \n",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 23,
      "section": "Rotate_by()"
    }
  },
  {
    "page_content": "reachy.head.rotate_by(roll=0, pitch=0, yaw=20, frame='head')\n\nreachy.head.rotate_by(roll=-30, pitch=0, yaw=0, frame='robot')",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 24,
      "section": "Rotate_by()"
    }
  },
  {
    "page_content": "## Read head position\n\nYou can read the head positions using : \n\n- Cartesian space : \n> `get_current_orientation()` will give the orientation as a quaternion\n\n\n- Joint space :  \n> `get_current_positions()` will give the neck's roll, pitch and yaw present_position\n\n### In cartesian space :",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 25,
      "section": "Read head position"
    }
  },
  {
    "page_content": "q = reachy.head.get_current_orientation()\nprint(q)",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 26,
      "section": "Read head position"
    }
  },
  {
    "page_content": "### In joint space : \n\nIn case you feel more comfortable using roll, pitch, yaw angles rather than working with quaternions, you can retrieve those values from the **neck joints**.",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 27,
      "section": "In joint space :"
    }
  },
  {
    "page_content": "reachy.head.goto([20, 20, -10], wait = True)\n\nreachy.head.get_current_positions()",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 28,
      "section": "In joint space :"
    }
  },
  {
    "page_content": "Then, you can reset the head to default position and turn it off.",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_markdown",
      "cell_number": 29,
      "section": "In joint space :"
    }
  },
  {
    "page_content": "reachy.head.goto_posture(common_posture=\"default\", wait=True)\n    \nreachy.turn_off_smoothly()",
    "metadata": {
      "source": "4_head_control.ipynb",
      "type": "notebook_code",
      "cell_number": 30,
      "section": "In joint space :"
    }
  },
  {
    "page_content": "# Getting started with Reachy 2",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 1,
      "section": "Getting started with Reachy 2"
    }
  },
  {
    "page_content": "In this first tutorial, we will familiarize ourselves with Reachy. We will cover how to connect to the robot and obtain basic information.",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 2,
      "section": "Getting started with Reachy 2"
    }
  },
  {
    "page_content": "## Connect to Reachy",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 3,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "First, establish a connection to your robot:",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 4,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "from reachy2_sdk import ReachySDK\n\nreachy = ReachySDK(host='localhost')  # Replace localhost with your robot's IP address",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_code",
      "cell_number": 5,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "You can check the connection status at any time with:",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 6,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "reachy.is_connected()",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_code",
      "cell_number": 7,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "Reachy is now ready for use. By default, all motors are turned off. In the next tutorial, we will learn how to move Reachy. The overall status of Reachy's motors can be checked as follows:",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 8,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "reachy.is_on() # will return False because the motors are off by default",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_code",
      "cell_number": 9,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "Let's retrieve information about the robot, including mode, serial number, hardware / software versions, and battery level:",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 10,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "reachy.info",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_code",
      "cell_number": 11,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "You can also access these informations independently, for example:",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 12,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "reachy.info.battery_voltage",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_code",
      "cell_number": 13,
      "section": "Connect to Reachy"
    }
  },
  {
    "page_content": "## Body parts",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 14,
      "section": "Body parts"
    }
  },
  {
    "page_content": "Let's take a look at Reachy's body. Reachy's arm has 7 degrees of freedom and one joint for the gripper.\n\nThe **arm** is divided into the following parts:\n- **shoulder**, consisting of 2 joints (pitch and roll)\n- **elbow**, consisting of 2 joints (yaw and pitch)\n- **wrist**, consisting of 3 joints (roll, pitch, and yaw)\n\nWe refer to the shoulder, elbow, and wrist as **actuators**. A joint is essentially an axis along which the actuator can rotate.\nFor some actions, such as changing the compliancy, this is the lowest level of control you will have.\n\nThe head consists of one actuator, the **neck**, with 3 degrees of freedom (joints).\n\nThe following command lists all available joints:",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 15,
      "section": "Body parts"
    }
  },
  {
    "page_content": "reachy.joints",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_code",
      "cell_number": 16,
      "section": "Body parts"
    }
  },
  {
    "page_content": "The current and goal positions are also listed (i.e., the present and target angles of the joints).\nEach body part can be explored individually:",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 17,
      "section": "Body parts"
    }
  },
  {
    "page_content": "reachy.r_arm.joints\n#reachy.l_arm.joints\n#reachy.head.joints",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_code",
      "cell_number": 18,
      "section": "Body parts"
    }
  },
  {
    "page_content": "## Mobile Base",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 19,
      "section": "Mobile Base"
    }
  },
  {
    "page_content": "The mobile base can be accessed in the same way as the body parts:\n> Be aware that there is no mobile base in the fake mode configuration. ",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 20,
      "section": "Mobile Base"
    }
  },
  {
    "page_content": "reachy.mobile_base",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_code",
      "cell_number": 21,
      "section": "Mobile Base"
    }
  },
  {
    "page_content": "## Disconnect",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 22,
      "section": "Disconnect"
    }
  },
  {
    "page_content": "No action is required; simply close your terminal or notebook!\n\nIf you need to switch between robots, you can disconnect from one and then connect to another:",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_markdown",
      "cell_number": 23,
      "section": "Disconnect"
    }
  },
  {
    "page_content": "reachy.disconnect()\n\nreachy = ReachySDK(host='localhost') # connect to a new robot with its IP address",
    "metadata": {
      "source": "1_getting_started.ipynb",
      "type": "notebook_code",
      "cell_number": 24,
      "section": "Disconnect"
    }
  },
  {
    "page_content": "Example script to display live frames from the teleoperation and depth cameras.",
    "metadata": {
      "source": "cameras.py",
      "type": "module_docstring"
    }
  },
  {
    "page_content": "Display live frames from the teleoperation camera.\n\nThis function retrieves and displays frames from the left and right\nviews of the teleoperation camera. The function terminates\nupon a keyboard interrupt.\n\nRaises:\n    SystemExit: If the teleop camera is not available.",
    "metadata": {
      "source": "cameras.py",
      "type": "function_docstring",
      "function": "display_teleop_cam",
      "class": null
    }
  },
  {
    "page_content": "def display_teleop_cam() -> None:\n    \"\"\"Display live frames from the teleoperation camera.\n\n    This function retrieves and displays frames from the left and right\n    views of the teleoperation camera. The function terminates\n    upon a keyboard interrupt.\n\n    Raises:\n        SystemExit: If the teleop camera is not available.\n    \"\"\"\n    if reachy.cameras.teleop is None:\n        exit(\"There is no teleop camera.\")\n\n    print(f\"Left camera parameters {reachy.cameras.teleop.get_parameters(CameraView.LEFT)}\")\n    print(f\"Left camera extrinsic parameters {reachy.cameras.teleop.get_extrinsics(CameraView.LEFT)}\")\n    # print(reachy.cameras.teleop.get_parameters(CameraView.RIGHT))\n\n    try:\n        while True:\n            frame, ts = reachy.cameras.teleop.get_frame(CameraView.LEFT)\n            frame_r, ts_r = reachy.cameras.teleop.get_frame(CameraView.RIGHT)\n            print(f\"timestamps secs: left {ts} - right {ts_r}\")\n            cv2.imshow(\"left\", frame)\n            cv2.imshow(\"right\", frame_r)\n            cv2.waitKey(1)\n\n    except KeyboardInterrupt:\n        logging.info(\"User Interrupt\")",
    "metadata": {
      "source": "cameras.py",
      "type": "function_definition",
      "function": "display_teleop_cam",
      "class": null
    }
  },
  {
    "page_content": "Display live frames from the depth camera.\n\nThis function retrieves and displays RGB and depth frames from the depth camera.\nIt normalizes the depth map for visualization and shows the RGB frame and normalized depth\nframe side by side. The function exits upon a keyboard interrupt.\n\nRaises:\n    SystemExit: If the depth camera is not available.",
    "metadata": {
      "source": "cameras.py",
      "type": "function_docstring",
      "function": "display_depth_cam",
      "class": null
    }
  },
  {
    "page_content": "def display_depth_cam() -> None:\n    \"\"\"Display live frames from the depth camera.\n\n    This function retrieves and displays RGB and depth frames from the depth camera.\n    It normalizes the depth map for visualization and shows the RGB frame and normalized depth\n    frame side by side. The function exits upon a keyboard interrupt.\n\n    Raises:\n        SystemExit: If the depth camera is not available.\n    \"\"\"\n    if reachy.cameras.depth is None:\n        exit(\"There is no depth camera.\")\n\n    print(f\"Depth camera parameters {reachy.cameras.depth.get_parameters()}\")\n    print(f\"Depth camera extrinsic parameters {reachy.cameras.depth.get_extrinsics()}\")\n\n    try:\n        while True:\n            rgb, ts = reachy.cameras.depth.get_frame()\n            depth, ts_r = reachy.cameras.depth.get_depth_frame()\n            depth_map_normalized = cv2.normalize(depth, None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8U)  # type: ignore [attr-defined]\n            cv2.imshow(\"frame\", rgb)\n            cv2.imshow(\"depthn\", depth_map_normalized)\n            cv2.waitKey(1)\n\n    except KeyboardInterrupt:\n        logging.info(\"User Interrupt\")",
    "metadata": {
      "source": "cameras.py",
      "type": "function_definition",
      "function": "display_depth_cam",
      "class": null
    }
  },
  {
    "page_content": "# The mobile base",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 1,
      "section": "The mobile base"
    }
  },
  {
    "page_content": "Reachy 2 is mounted on a mobile base!",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 2,
      "section": "The mobile base"
    }
  },
  {
    "page_content": "## Initialize your robot\n\nFirst connect to your robot:",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 3,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "from reachy2_sdk import ReachySDK\n\nreachy = ReachySDK(host='localhost')  # Replace with the actual IP",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 4,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "Let's check what contains the mobile base part:",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 5,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "reachy.mobile_base",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 6,
      "section": "Initialize your robot"
    }
  },
  {
    "page_content": "## Move around",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 7,
      "section": "Move around"
    }
  },
  {
    "page_content": "Three modes are possible to control the mobile base:\n- **goto** : move the mobile base to a target point in space -> use a *goto function* to get in this mode\n- **free wheel**: unlock the wheel so Reachy can be manually moved around easily -> *turn_off() method* will set this mode\n- **brake**: stop the movement and lock the wheels -> *turn_on() method* will set this mode",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 8,
      "section": "Move around"
    }
  },
  {
    "page_content": "### Goto and odometry\n\nThe goto function is used to place the mobile_base at a relative position and orientation to its odometry, set when the robot is switched on. To be sure, you can reset the odometry before calling the function. ",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 9,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "reachy.mobile_base.turn_on()\n\nreachy.mobile_base.reset_odometry()\n\n# Move 20 cm forward\nreachy.mobile_base.goto(x=0.2, y=0.0, theta=0.0)",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 10,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "reachy.mobile_base.goto(x=0.2, y=0.0, theta=0)\n",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 11,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "If you want to move forward again the robot, you need to increase the x value.",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 12,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "import time\n\nreachy.mobile_base.goto(x=0.2, y=0.0, theta=0.0) #that won't do anything as the robot is already there\ntime.sleep(2)\n\n# Move again 20cm forward\nreachy.mobile_base.goto(x=0.4, y=0.0, theta=0.0)",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 13,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "That's the same for the rotation. You can go back to the initial position than rotate the mobile base. ",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 14,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "# Go back to the initial position\nreachy.mobile_base.goto(x=0.0, y=0.0, theta=0.0)\n\ntime.sleep(2)\n\n# Rotation to be at 90 degrees in the frame\nreachy.mobile_base.goto(x=0.0, y=0.0, theta=90.0)",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 15,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "> Be careful, goto is not a *Goto* method as for the arms. It's a blocking function, meaning that the move needs to be finished before the rest of the code starts to execute. So, the goto id will return once the movement is done, or the timeout expired. If you need to run this function in parallel to other processing, please check the `goto_async`",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 16,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "# Go back to 0 degree in the frame\nreachy.mobile_base.goto(x=0.0, y=0.0, theta=0.0)",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 17,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "# Rotation to be at 90 degrees in the frame\nreachy.mobile_base.goto(x=0.0, y=0.0, theta=90.0)\n\n# Reset odometry\nreachy.mobile_base.reset_odometry()\n# Go back to 0 degree in the frame : it won't move because the frame has changed\nreachy.mobile_base.goto(x=0.0, y=0.0, theta=0.0)\n",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 18,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "# Rotation to be at -90 degrees in the new frame\nreachy.mobile_base.goto(x=0.0, y=0.0, theta=-90.0)",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 19,
      "section": "Goto and odometry"
    }
  },
  {
    "page_content": "#### Rotate_by / Translate_by\n\nYou can also decide to assign movements to the robot based on its current position and not on its odometry. ",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 20,
      "section": "Rotate_by / Translate_by"
    }
  },
  {
    "page_content": "reachy.mobile_base.get_current_odometry()\nreachy.mobile_base.translate_by(x = 0.2, y = 0.0)",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 21,
      "section": "Rotate_by / Translate_by"
    }
  },
  {
    "page_content": "You can do it again, to move the robot by 0.2m in the x direction.",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 22,
      "section": "Rotate_by / Translate_by"
    }
  },
  {
    "page_content": "reachy.mobile_base.translate_by(x = 0.2, y = 0.0)",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 23,
      "section": "Rotate_by / Translate_by"
    }
  },
  {
    "page_content": "Now, the mobile base can be rotated 90\u00b0 from its current position, allowing to get a odometry with a theta = 0\u00b0. ",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 24,
      "section": "Rotate_by / Translate_by"
    }
  },
  {
    "page_content": "reachy.mobile_base.rotate_by(theta = 90.0)\nreachy.mobile_base.get_current_odometry()",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 25,
      "section": "Rotate_by / Translate_by"
    }
  },
  {
    "page_content": "The speed of the movement can be defined using this command : *this will assign speed to the robot for 200ms*",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 26,
      "section": "Rotate_by / Translate_by"
    }
  },
  {
    "page_content": "reachy.mobile_base.set_goal_speed(x=1.0, y=1.0, theta=2)\nreachy.mobile_base.send_speed_command()",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 27,
      "section": "Rotate_by / Translate_by"
    }
  },
  {
    "page_content": "### Free wheel",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_markdown",
      "cell_number": 28,
      "section": "Free wheel"
    }
  },
  {
    "page_content": "reachy.mobile_base.turn_off()",
    "metadata": {
      "source": "7_mobile_base.ipynb",
      "type": "notebook_code",
      "cell_number": 29,
      "section": "Free wheel"
    }
  },
  {
    "page_content": "# Get images from cameras",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 1,
      "section": "Get images from cameras"
    }
  },
  {
    "page_content": "Reachy 2 has 2 types of camera:\n\n- the **teleop** cameras, with a right and left cameras, located in Reachy 2\u2019s head and used for the teleoperation\n- the **depth** camera, equipped with a depth sensor, located in Reachy 2\u2019s torso and mainly useful for manipulation tasks\n\nEach camera can be accessed separately through reachy.cameras. Teleop cameras  have a right and left view, with the left and right sides considered from Reachy point of view, while the depth camera has a left (i.e. mono RGB) and depth view. To be able to specify the view you want to get a frame from, you will need to import CameraView:",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 2,
      "section": "Get images from cameras"
    }
  },
  {
    "page_content": "```python\nfrom reachy2_sdk.media.camera import CameraView\n```",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 3,
      "section": "Get images from cameras"
    }
  },
  {
    "page_content": "## Get images",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 4,
      "section": "Get images"
    }
  },
  {
    "page_content": "First, connect to your robot.  \n**Do not forget to import the CameraView!**",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 5,
      "section": "Get images"
    }
  },
  {
    "page_content": "from reachy2_sdk.media.camera import CameraView\nfrom reachy2_sdk import ReachySDK\n\nreachy = ReachySDK(host='localhost')  # Replace with the actual IP",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 6,
      "section": "Get images"
    }
  },
  {
    "page_content": "Check the list of initialized cameras:",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 7,
      "section": "Get images"
    }
  },
  {
    "page_content": "reachy.cameras",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 8,
      "section": "Get images"
    }
  },
  {
    "page_content": "The list of initialized cameras should contain both the teleop and depth cameras.  ",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 9,
      "section": "Get images"
    }
  },
  {
    "page_content": "### Teleop cameras\n\nTo get both views of the robot teleop cameras:",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 10,
      "section": "Teleop cameras"
    }
  },
  {
    "page_content": "l_frame, l_ts = reachy.cameras.teleop.get_frame(CameraView.LEFT)\nr_frame, r_ts = reachy.cameras.teleop.get_frame(CameraView.RIGHT)",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 11,
      "section": "Teleop cameras"
    }
  },
  {
    "page_content": "We can print the timestamp of each frame (in nanosecond)",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 12,
      "section": "Teleop cameras"
    }
  },
  {
    "page_content": "print(f\"timestamp left frame {l_ts} - timestamp right frame {r_ts}\")",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 13,
      "section": "Teleop cameras"
    }
  },
  {
    "page_content": "Let's display the captured frame with PIL:",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 14,
      "section": "Teleop cameras"
    }
  },
  {
    "page_content": "from PIL import Image",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 15,
      "section": "Teleop cameras"
    }
  },
  {
    "page_content": "Image.fromarray(l_frame[:,:,::-1])",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 16,
      "section": "Teleop cameras"
    }
  },
  {
    "page_content": "The camera parameters, as defined [here](https://docs.ros.org/en/melodic/api/sensor_msgs/html/msg/CameraInfo.html), are also available",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 17,
      "section": "Teleop cameras"
    }
  },
  {
    "page_content": "height, width, distortion_model, D, K, R, P =  reachy.cameras.teleop.get_parameters(CameraView.LEFT)\nprint(f\"height: {height}\")\nprint(f\"width: {width}\")\nprint(f\"distortion model: {distortion_model}\")\nprint(f\"distortion coefficients {D}\")\nprint(f\"instrinsic matrix {K}\")\nprint(f\"rectification matrix {R}\")\nprint(f\"projection matrix {P}\")",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 18,
      "section": "Teleop cameras"
    }
  },
  {
    "page_content": "### Depth camera\n\nThe depth camera works exactly the same as the teleop camera, but you have more elements captured. In fact, it's a RGBD camera, so you have both access to the RGB image and depth information.\n\n",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 19,
      "section": "Depth camera"
    }
  },
  {
    "page_content": "#### RGB images\n\nGetting RGB images from the depth camera looks the same as from the teleop one:  simply use `get_frame()`, there is only one view.",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 20,
      "section": "RGB images"
    }
  },
  {
    "page_content": "frame, ts = reachy.cameras.depth.get_frame()",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 21,
      "section": "RGB images"
    }
  },
  {
    "page_content": "Let's display the captured frame with PIL:",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 22,
      "section": "RGB images"
    }
  },
  {
    "page_content": "Image.fromarray(frame[:,:,::-1])",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 23,
      "section": "RGB images"
    }
  },
  {
    "page_content": "As for the teleop camera, parameters are also availables",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 24,
      "section": "RGB images"
    }
  },
  {
    "page_content": "height, width, distortion_model, D, K, R, P =  reachy.cameras.depth.get_parameters()\nprint(f\"height: {height}\")\nprint(f\"width: {width}\")\nprint(f\"distortion model: {distortion_model}\")\nprint(f\"distortion coefficients {D}\")\nprint(f\"instrinsic matrix {K}\")\nprint(f\"rectification matrix {R}\")\nprint(f\"projection matrix {P}\")",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 25,
      "section": "RGB images"
    }
  },
  {
    "page_content": "#### Depth information\n\nThe SR camera is a depth camera, you can then diplay a left or right **depth frame** using `get_depth_frame()`, but also the **depthmap** and the **disparity**.   \n\nYou first have to capture all, then you can read the frame and get the information you want:",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 26,
      "section": "Depth information"
    }
  },
  {
    "page_content": "depth_frame, ts = reachy.cameras.depth.get_depth_frame()",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 27,
      "section": "Depth information"
    }
  },
  {
    "page_content": "Let's display the captured frame with PIL:",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 28,
      "section": "Depth information"
    }
  },
  {
    "page_content": "Image.fromarray(depth_frame[:,:])",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 29,
      "section": "Depth information"
    }
  },
  {
    "page_content": "If needed, camera parameters for the depth view are also available",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 30,
      "section": "Depth information"
    }
  },
  {
    "page_content": "height, width, distortion_model, D, K, R, P =  reachy.cameras.depth.get_parameters(CameraView.DEPTH)\nprint(f\"height: {height}\")\nprint(f\"width: {width}\")\nprint(f\"distortion model: {distortion_model}\")\nprint(f\"distortion coefficients {D}\")\nprint(f\"instrinsic matrix {K}\")\nprint(f\"rectification matrix {R}\")\nprint(f\"projection matrix {P}\")",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_code",
      "cell_number": 31,
      "section": "Depth information"
    }
  },
  {
    "page_content": "## Live stream",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 32,
      "section": "Live stream"
    }
  },
  {
    "page_content": "Although we provide an optimal way to get the video stream, it is still possible to display what Reachy see through the SDK. It could be useful to feed a compute vision algorithm that do not need to run at high frequency.\n\nThis is demonstrated in a dedicated script : [cameras.py](cameras.py)",
    "metadata": {
      "source": "5_cameras_images.ipynb",
      "type": "notebook_markdown",
      "cell_number": 33,
      "section": "Live stream"
    }
  },
  {
    "page_content": "Example of setting Reachy to zero pose using Reachy SDK.",
    "metadata": {
      "source": "set_default_posture.py",
      "type": "module_docstring"
    }
  }
]