[
  {
    "type": "tutorial",
    "name": "3_arm_and_gripper.ipynb",
    "path": "3_arm_and_gripper.ipynb",
    "content": "{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"0\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Arm and Gripper\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"1\",\n   \"metadata\": {},\n   \"source\": [\n    \"In the previous tutorial, we explored the concept of *goto* and basic control. Now, let's delve deeper into what we can do with Reachy's arms and grippers.\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"2\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Initialize Your Robot\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"3\",\n   \"metadata\": {},\n   \"source\": [\n    \"First, connect to your robot:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"4\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from reachy2_sdk import ReachySDK\\n\",\n    \"import time\\n\",\n    \"\\n\",\n    \"reachy = ReachySDK(host='localhost')  # Replace with the actual IP adress of your robot\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"5\",\n   \"metadata\": {},\n   \"source\": [\n    \"Next, we need to turn on the parts we want to use:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"6\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.turn_on()\\n\",\n    \"reachy.r_arm.turn_on()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"7\",\n   \"metadata\": {},\n   \"source\": [\n    \"Since the grippers are part of the arms, they will also be turned on. You could, of course, turn on the whole robot by calling `reachy.turn_on()` directly.\\n\",\n    \"Let's check if the arms are on:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"8\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"print(reachy.r_arm.is_on())\\n\",\n    \"print(reachy.l_arm.is_on())\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"9\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Control the arms\\n\",\n    \"\\n\",\n    \"Arms can be controlled in two spaces:\\n\",\n    \"\\n\",\n    \"* the **joint space**, which allows to read and write directly the angle values of each joint of the arm\\n\",\n    \"* the **cartesian space**, which consists in controlling the end effector position and orientation in Reachy's coordinate system\\n\",\n    \"\\n\",\n    \"> Both spaces are quite different, and **we advise not to mix them** if you are not familiar with the output.\\n\",\n    \"In fact, values of the joint space are expressed in each actuator's coordinate system (respectively shoulder, elbow and wrist), whereas commands in cartesian space are expressed in Reachy's coordinate system\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"10\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Joint space\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"11\",\n   \"metadata\": {},\n   \"source\": [\n    \"Reachy's arm offers 7 degrees of freedom. It also gives access to one joint for the gripper.\\n\",\n    \"The arm is divided as follow:\\n\",\n    \"- shoulder, composed of 2 joints (pitch and roll)\\n\",\n    \"- elbow, composed of 2 joints (yaw and pitch)\\n\",\n    \"- wrist, composed of 3 joints (roll, pitch and yaw)\\n\",\n    \"\\n\",\n    \"We refer to the shoulder, elbow and wrist as actuators.\\n\",\n    \"For some actions, such as changing the compliancy, it is the lowest level of control you will have.\\n\",\n    \"\\n\",\n    \"You can inspect the details of the arm with:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"12\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.r_arm.joints\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"13\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.joints\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"14\",\n   \"metadata\": {},\n   \"source\": [\n    \"You can easily access the position of each joint in one call with `get_current_positions()`.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"15\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.r_arm.get_current_positions()\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"16\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.get_current_positions()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"17\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### Move the arms in joint space\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"18\",\n   \"metadata\": {},\n   \"source\": [\n    \"The simplest way to move an arm is to set the angle of each joint. Define a joint positions list:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"19\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"r_elbow_at_90_deg = [0, 10, -15, -90, 0, 0, -5]\\n\",\n    \"l_elbow_at_90_deg = [0, -10, 15, -90, 0, 0, 5]\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"20\",\n   \"metadata\": {},\n   \"source\": [\n    \"Send the joint goal positions to the arm with `goto()`\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"21\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.r_arm.goto(r_elbow_at_90_deg)\\n\",\n    \"reachy.l_arm.goto(l_elbow_at_90_deg, wait = True)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"22\",\n   \"metadata\": {},\n   \"source\": [\n    \"In order to easily move a single joint, we can use the `goto()` method on a given joint:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"23\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.r_arm.elbow.pitch.goto(0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"24\",\n   \"metadata\": {},\n   \"source\": [\n    \"This method works exactly like a goto on the part. All gotos sent to joints are stacked on the part they belong to.\\n\",\n    \"For example:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"25\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"part_goto_id = reachy.r_arm.goto([0, 10, -15, -90, 0, 0, -5])\\n\",\n    \"joint_goto_id = reachy.r_arm.elbow.pitch.goto(0)\\n\",\n    \"\\n\",\n    \"print(part_goto_id)\\n\",\n    \"print(joint_goto_id)\\n\",\n    \"\\n\",\n    \"print(reachy.r_arm.get_goto_queue())\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"26\",\n   \"metadata\": {},\n   \"source\": [\n    \"`reachy.r_arm.elbow.pitch.goto(0)` command is stacked in r_arm gotos queue.\\n\",\n    \"The goto on the elbow will be played when the previous command sent using `goto()` will be over.\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"27\",\n   \"metadata\": {},\n   \"source\": [\n    \"The arms should have moved in a way similar to what we saw in the [goto tutorial](2_goto_introduction.ipynb). You already know that you can specify the duration or the interpolation mode of this kind of movement.\\n\",\n    \"\\n\",\n    \"We've only seen movements expressed in the 'joint space', i.e., defined by a set of angles. How can we know the position of the gripper in space, or how can we reach an object for which we know its position? That's where kinematics come in.\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"28\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Kinematics\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"29\",\n   \"metadata\": {},\n   \"source\": [\n    \"The kinematic model describes the motion of a robot in mathematical form without considering the forces and torque affecting it. It only focuses on the geometric relationship between elements.\\n\",\n    \"\\n\",\n    \"We have defined the whole kinematic model of the arm. This means the translation and rotation required to go from one joint to the next one. \\n\",\n    \"\\n\",\n    \"[Long story](https://pollen-robotics.github.io/reachy2-docs/developing-with-reachy-2/basics/4-use-arm-kinematics/) short, there are two types of kinematics:\\n\",\n    \"- Forward kinematics: from the joints position, the gripper position is computed in cartesian space\\n\",\n    \"- Inverse kinematics: from a given gripper position to reach, all joints positions are computed in joint space\\n\",\n    \"\\n\",\n    \"> You can easily use forward kinematics and inverse kinematics to switch respectively from joint space to cartesian space and from cartesian space to joint space.\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"30\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### Forward Kinematics\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"31\",\n   \"metadata\": {},\n   \"source\": [\n    \"Each arm has a `forward_kinematics` method that computes a 4x4 pose matrix (position and orientation of the gripper in space). For instance, the previous movement left the left elbow at 90\u00b0. The position (x, y, z) of the gripper is:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"32\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.forward_kinematics()[:3, 3]\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"33\",\n   \"metadata\": {},\n   \"source\": [\n    \"It is not mandatory to move the arm to compute forward kinematics. This can be done for any set of joint positions such as:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"34\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.forward_kinematics([10, 0, 0, -90, 0, 0, 0])\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"35\",\n   \"metadata\": {},\n   \"source\": [\n    \"Reachy didn't move, but you know where it would have gone with an additional 10\u00b0 applied to the shoulder joint.\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"36\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### Inverse Kinematics\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"37\",\n   \"metadata\": {},\n   \"source\": [\n    \"Inverse kinematics works in the opposite way. Let's say you want to reach an object for which you know its position. What would be the set of joint positions to provide to `goto`?\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"38\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"import numpy as np\\n\",\n    \"target = np.identity(4)\\n\",\n    \"target = np.array([[0, 0, -1, 0.3],\\n\",\n    \"    [0, 1, 0, 0.1],\\n\",\n    \"    [1, 0, 0, -0.3],\\n\",\n    \"    [0, 0, 0, 1]])\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"39\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"joints_positions = reachy.l_arm.inverse_kinematics(target)\\n\",\n    \"joints_positions\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"40\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.goto(joints_positions)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"41\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.goto_posture(\\\"default\\\")\\n\",\n    \"reachy.l_arm.goto(target, wait = True)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"42\",\n   \"metadata\": {},\n   \"source\": [\n    \"> All these goto are illustrated in [draw_square](draw_square.py). Check it out to see how to make Reachy draw a square with its right arm!\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"43\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Cartesian space\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"44\",\n   \"metadata\": {},\n   \"source\": [\n    \"Controlling the arm in cartesian space allows you to control the position of the gripper in Reachy's coordinate system. It is the recommended way to control the robot for grasping goals.  \\n\",\n    \"Let's got back to the *elbow_90* pose:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"45\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.goto_posture('elbow_90', wait = True)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"46\",\n   \"metadata\": {},\n   \"source\": [\n    \"You can easily access the current pose of the gripper using the previously seen method `forward_kinematics()`\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"47\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"current_pose = reachy.l_arm.forward_kinematics()\\n\",\n    \"print(current_pose)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"48\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### Move the arms in cartesian space\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"49\",\n   \"metadata\": {},\n   \"source\": [\n    \"To control the arm in cartesian space, use the `goto(...)` method.  \\n\",\n    \"Let's use it on the current_pose:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"50\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.goto(current_pose)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"51\",\n   \"metadata\": {},\n   \"source\": [\n    \"As you have just seen, the arm moved meanwhile the gripper is in the exact same position and orientation: that's because the computed inverse kinematics solution is different from the joints we decided to choose in joint space (`goto_posture()` is in fact a joint space method).  \\n\",\n    \"\\n\",\n    \"Let's send the arm to a new goal pose.  \\n\",\n    \"We need to define a pose 4x4 matrix as the new goal pose for the gripper:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"52\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"new_pose = current_pose.copy()\\n\",\n    \"new_pose[0, 3] += 0.1\\n\",\n    \"print(new_pose)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"53\",\n   \"metadata\": {},\n   \"source\": [\n    \"This new_pose is translated 10cm front in Reachy's coordinate system (+10cm on Reachy's x axis).  \\n\",\n    \"You can send it to the robot:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"54\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.goto(new_pose)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"55\",\n   \"metadata\": {},\n   \"source\": [\n    \"To simplify your life, you have access to functions to easily compute translation or rotation.  \\n\",\n    \"Use the `translate_by(...)` method to send the gripper back to the previous pose, asking for a translation 10cm back (-10cm on Reachy's x axis):\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"56\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.translate_by(-0.1, 0, 0, frame='robot')\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"57\",\n   \"metadata\": {},\n   \"source\": [\n    \"You can easily make the gripper rotate with the `rotate_by(...)` method:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"58\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.rotate_by(10, 0, 0, frame='gripper')\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"59\",\n   \"metadata\": {},\n   \"source\": [\n    \"The gripper rotate by 10 degrees around the x axis of the gripper.  \\n\",\n    \"For both functions, you need to specify a frame:\\n\",\n    \"* setting **gripper** as frame will translate or rotate in the gripper coordinate system\\n\",\n    \"* setting **robot** as frame will translate or rotate directly in Reachy's coordinate system\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"60\",\n   \"metadata\": {},\n   \"source\": [\n    \"If you want to compute a translation or rotation without making the robot move, you can call `get_translation_by(...)` and `get_rotation_by(...)` to get the corresponding pose 4x4 matrix:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"61\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.get_translation_by(-0.1, 0.2, -0.1, frame='gripper')\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"62\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.get_rotation_by(-10, 20, 0, frame='gripper')\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"63\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Gripper Control\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"64\",\n   \"metadata\": {},\n   \"source\": [\n    \"Finally, you may want to open or close a gripper to grab an object! Use the `close` or `open` method to do so:\\n\",\n    \"> Those methods can't be set as blocking moves for now, so you need to add a waiting condition while the gripper is still moving. \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"65\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.gripper.close()\\n\",\n    \"while reachy.l_arm.gripper.is_moving():\\n\",\n    \"    time.sleep(0.1)\\n\",\n    \"reachy.l_arm.gripper.open()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"66\",\n   \"metadata\": {},\n   \"source\": [\n    \"Of course, you can partially open the gripper, and get its current opening:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"67\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.gripper.set_opening(55)\\n\",\n    \"while reachy.l_arm.gripper.is_moving():\\n\",\n    \"    time.sleep(0.1)\\n\",\n    \"reachy.l_arm.gripper.get_current_opening()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"68\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Set robot back to compliant mode\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"69\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default', duration = 2, wait = True)\\n\",\n    \"    \\n\",\n    \"reachy.turn_off_smoothly()\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"reachy10\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.10.14\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n"
  },
  {
    "type": "tutorial",
    "name": "6_audio.ipynb",
    "path": "6_audio.ipynb",
    "content": "{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"0\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Make some noise\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"2\",\n   \"metadata\": {},\n   \"source\": [\n    \"Reachy 2 has two microphones located on each antenna and one speaker inside its torso. The audio API allows you to record and play audio files.\\n\",\n    \"\\n\",\n    \"***Note that, for now, the audio files are located in a temporary folder on Reachy's computer and are deleted at each reboot of the robot. The file management is very basic, allowing just a list of files in a single folder.***\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"4\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Manage the sound files\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"5\",\n   \"metadata\": {},\n   \"source\": [\n    \"First, connect to your robot.  \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"6\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from reachy2_sdk import ReachySDK\\n\",\n    \"\\n\",\n    \"reachy = ReachySDK(host='localhost')  # Replace with the actual IP\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"7\",\n   \"metadata\": {},\n   \"source\": [\n    \"You can first check the audio files available on Reachy.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"8\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.get_audio_files()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"9\",\n   \"metadata\": {},\n   \"source\": [\n    \"The list may be empty if you have just started to play with Reachy. Let's add a new audio file. Reachy is able to play wav, mp3, and ogg files. Ogg files can be downloaded [here for instance](https://getsamplefiles.com/sample-audio-files/ogg).\\n\",\n    \"Make sure to change the path name in the line below. For instance */home/name/Downloads/sample-1.ogg* or *C:\\\\Users\\\\name\\\\Downloads\\\\sample-1.ogg*\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"c068ad53\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.upload_audio_file('<path>/sample-1.ogg')\\n\",\n    \"reachy.audio.upload_audio_file('<path>/sample-4.ogg')\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"dc7eb487\",\n   \"metadata\": {},\n   \"source\": [\n    \"Now these two files should be listed on Reachy:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"f93e5709\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.get_audio_files()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"9ff75b25\",\n   \"metadata\": {},\n   \"source\": [\n    \"A file can be removed if you don't want to use it. It should no longer be in the list!\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"076a76e3\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.remove_audio_file('sample-4.ogg')\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"823fb0fa\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.get_audio_files()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"10\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Play a sound\\n\",\n    \"\\n\",\n    \"Once an audio file is uploaded onto Reachy, you can play it\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 17,\n   \"id\": \"11\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.play_audio_file('sample-1.ogg')\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"12\",\n   \"metadata\": {},\n   \"source\": [\n    \"Stop the playback whenever you want\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 18,\n   \"id\": \"13\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.stop_playing()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"4f77bc1e\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Record a sound\\n\",\n    \"\\n\",\n    \"In a similar way, a sound can be recorded using Reachy's microphones. Only the ogg extension is allowed for now. The duration of the recording, in seconds, must be set.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"b8379a6c\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.record_audio('tutorial.ogg', duration_secs=5)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"0738588b\",\n   \"metadata\": {},\n   \"source\": [\n    \"The audio is recorded in the background; it may be stopped at any time.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 11,\n   \"id\": \"1d03a93a\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.stop_recording()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"835b2865\",\n   \"metadata\": {},\n   \"source\": [\n    \"The audio file is now on Reachy's file system, and available for listening\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"6038c1c1\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.get_audio_files()\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": 5,\n   \"id\": \"89beb16a\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.play_audio_file('tutorial.ogg')\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"7cd3afb1\",\n   \"metadata\": {},\n   \"source\": [\n    \"Finally, the audio file can be downloaded to your local machine.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"7178c172\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.audio.download_audio_file('tutorial.ogg', '<path>')\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"sdkv2\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.10.15\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n"
  },
  {
    "type": "tutorial",
    "name": "2_goto_introduction.ipynb",
    "path": "2_goto_introduction.ipynb",
    "content": "{\n \"cells\": [\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"0\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Goto introduction\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"1\",\n   \"metadata\": {},\n   \"source\": [\n    \"ReachySDK for Reachy 2 offers you methods to make movements with the arms and head, controlling the target position in several ways, choosing the duration of the movement, or even the interpolation mode. We called them **Goto**.\\n\",\n    \"\\n\",\n    \"Those methods work the same way on the arms and on the head, **but not on the mobile base**.\\n\",\n    \"\\n\",\n    \"The methods to use in order to control the robot are:\\n\",\n    \"-  for the arms:  \\n\",\n    \"    - **`goto()`**: depending on the parameter entered, you can control either :\\n\",\n    \"        - the joint value of each joint in degrees : *list of 7 values (joint space)*\\n\",\n    \"        - the end-effector position in the robot frame of reference : *4x4 homogeneous matrix (cartesian space)*\\n\",\n    \"    - **`translate_by()`** and **`rotate_by()`** : you can translate or rotate the position of the end-effector in space, in robot frame or gripper frame\\n\",\n    \"\\n\",\n    \"- for the head:  \\n\",\n    \"    - **`goto()`**: depending on the parameter entered, you can control either :\\n\",\n    \"        - the joint value of each head joint in degrees : *list of  3 values (joint space)*\\n\",\n    \"        - the head orientation in the robot frame : *quaternion (cartesian space)*\\n\",\n    \"        > Be careful that, between the joint and cartesian spaces, there is a 10-degree difference in pitch : to have the head looking forward, in joint space you have to put rpy = [0,10,0] whereas in cartesian space, it's the equivalent of [0,0,0].\\n\",\n    \"    \\n\",\n    \"    - **`look_at()`**: you control the head by giving a point in the robot coordinate system the head will look at\\n\",\n    \"    - **`rotate_by()`**: you can rotate the head in relation to its current position, by setting roll, pitch and yaw values in degrees, either in relation to the robot's frame of reference or to the head.\\n\",\n    \"\\n\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"2\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Initialize to your robot\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"3\",\n   \"metadata\": {},\n   \"source\": [\n    \"Connect to your robot:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"4\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from reachy2_sdk import ReachySDK\\n\",\n    \"import time # used for time.sleep() later in the tutorial\\n\",\n    \"\\n\",\n    \"reachy = ReachySDK(host='localhost')  #Replace localhost with your robot's IP address\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"5\",\n   \"metadata\": {},\n   \"source\": [\n    \"Turn on Reachy so the motors can be controlled, and set in the default posture :\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"6\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.turn_on()\\n\",\n    \"\\n\",\n    \"reachy.goto_posture('default')\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"7\",\n   \"metadata\": {},\n   \"source\": [\n    \"`goto_posture()` is a convenient function to configure the posture of all Reachy parts at once. \\n\",\n    \"\\n\",\n    \"It accepts the parameters : \\n\",\n    \"- *default* (i.e. `goto_posture('default')`), which gives Reachy's default pose with arms outstretched on either side of the body,\\n\",\n    \"- *elbow_90* (i.e. `goto_posture('elbow_90')`), in which Reachy has the two forearms parallel to the ground. \\n\",\n    \"\\n\",\n    \"These standard poses can be useful when you want to start a new task from a known position.\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"8\",\n   \"metadata\": {},\n   \"source\": [\n    \"> This example is available in [set_default_posture.py](set_default_posture.py)\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"9\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Set your First Move\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"10\",\n   \"metadata\": {},\n   \"source\": [\n    \"Let's move Reachy's right arm. The *goto* allows to control the 7 degrees of freedom of the arm at once (see [getting_started](1_getting_started.ipynb))\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"11\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"goto_1 = reachy.r_arm.goto([0, 10, -10, -90, 0, 0, 0])\\n\",\n    \"\\n\",\n    \"print(f'goto 1 {goto_1}')\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"12\",\n   \"metadata\": {},\n   \"source\": [\n    \"This method returns an id, that you can use to get information on this movement or to cancel this movement. Store this id in a variable (*goto_1* here) to be able to use it further. All the goto methods return an id.\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"13\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Goto commands\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"14\",\n   \"metadata\": {},\n   \"source\": [\n    \"A goto command can only be sent on parts:\\n\",\n    \"- reachy.l_arm\\n\",\n    \"- reachy.r_arm\\n\",\n    \"- reachy.head\\n\",\n    \"\\n\",\n    \"and is defined by 3 parameters : \\n\",\n    \"- the **joint commands**, as a list of articular degree values (7 for the arms and 3 for the head)\\n\",\n    \"- the **duration**, in seconds - *set to 2 by default*\\n\",\n    \"- the **interpolation mode**, 'linear' or 'minimum_jerk' - *set to 'minimum_jerk' by default*\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"15\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### Goto duration \\n\",\n    \"\\n\",\n    \"You can give a custom duration for the execution of the movements, as shown in the examples above : \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"17\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.head.goto([20, 20, -10], duration = 3)\\n\",\n    \"reachy.l_arm.goto([0, -10, 10, -90, 0, 0, 0], duration = 5)\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"# Doing:\\n\",\n    \"reachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0])\\n\",\n    \"# will lead to the same result as:\\n\",\n    \"reachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], duration = 2)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"18\",\n   \"metadata\": {},\n   \"source\": [\n    \"> Default duration is **2 seconds**.\\n\",\n    \"\\n\",\n    \"You **cannot set a duration to 0 second**. This will raise an exception in your code!\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"19\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.goto([0, 0, 0, 0, 0, 0, 0], duration = 0) # raises an exception\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"20\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### Goto interpolation mode\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"21\",\n   \"metadata\": {},\n   \"source\": [\n    \"The goto methods generates a trajectory between the present position and the goal position. This trajectory is then interpolated at a predefined frequency (100Hz) to compute all intermediary target positions that should be followed before reaching the final goal position. Depending on the interpolation mode chosen, you can have a better control over speed and acceleration.\\n\",\n    \"\\n\",\n    \"Two interpolation modes are available when sending a goto command:\\n\",\n    \"- the **linear** interpolation mode\\n\",\n    \"- the **minimum-jerk** interpolation mode\\n\",\n    \"\\n\",\n    \"Both trajectories start and finish at the same point but don't follow the same intermediate positions. The minimum jerk will slowly accelerate at the begining and slowly decelerate at the end. This makes the movements more natural.\\n\",\n    \"\\n\",\n    \"You can specify the interpolation mode by setting the **`interpolation_mode`** argument when calling the method:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"22\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default', wait = True)\\n\",\n    \"reachy.head.goto([20, 20, -10], interpolation_mode='linear')\\n\",\n    \"reachy.l_arm.goto([0, -10, 10, -90, 0, 0, 0], interpolation_mode='linear')\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"23\",\n   \"metadata\": {},\n   \"source\": [\n    \"> Default interpolation mode is **minimum_jerk**.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"24\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Doing:\\n\",\n    \"reachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0])\\n\",\n    \"# will lead to the same result as:\\n\",\n    \"reachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], interpolation_mode='minimum_jerk')\\n\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"25\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Goto execution\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"26\",\n   \"metadata\": {},\n   \"source\": [\n    \"There are two important concepts to be aware of : \\n\",\n    \"- gotos are stacked for a part (i.e. they run one after another),\\n\",\n    \"- but each part is independent (i.e. a goto for the left arm will run in parallel with a goto for the right arm).\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"27\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Goto is non-blocking for other parts \"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"28\",\n   \"metadata\": {},\n   \"source\": [\n    \"It means you can send a goto command on different parts, it won't wait for the movement to be executed on the first part to execute the other one, but will follow the timing of your code.\\n\",\n    \"\\n\",\n    \"Let's take an example with a motion sequence : \\n\",\n    \"\\n\",\n    \"- Start by returning the robot to its neutral position.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"29\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default')\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"30\",\n   \"metadata\": {},\n   \"source\": [\n    \"- Send a goto on both arms, with a delay between them. \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"31\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.l_arm.goto([0, 0, 10, -90, 0, 0, 15], duration = 3)\\n\",\n    \"time.sleep(1)\\n\",\n    \"reachy.r_arm.goto([0, 0, -10, -90, 0, 0, -15], duration = 2)\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"32\",\n   \"metadata\": {},\n   \"source\": [\n    \"This sequence will take 3 seconds to execute, as the right arm will start its movement 1 second after the left arm has started its own movement. They will finish at the same time.\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"33\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Goto is blocking and stacked for a part\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"34\",\n   \"metadata\": {},\n   \"source\": [\n    \"It means that you can send several goto commands on a part one after another without any delay, they will be played in this order, but will wait for the previous goto to be finished.  \\n\",\n    \"\\n\",\n    \"Let's take an example with the following sequence:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"36\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default')\\n\",\n    \"reachy.l_arm.goto([0, 0, 15, -90, 0, 0, 15], duration = 3)\\n\",\n    \"reachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], duration = 2)\\n\",\n    \"reachy.l_arm.goto([0, 0, 15, -90, 0, 0, 15], duration = 3)\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"37\",\n   \"metadata\": {},\n   \"source\": [\n    \"This sequence will take 8 seconds to execute, as each movement on the left arm will wait for the previous before starting.  \\n\",\n    \"\\n\",\n    \"Nevertheless, you can still send goto commands to other parts.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"39\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default')\\n\",\n    \"\\n\",\n    \"reachy.l_arm.goto([0, 0, 15, -90, 0, 0, 15], duration = 3)  #1\\n\",\n    \"time.sleep(1)\\n\",\n    \"reachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], duration = 2)  #2\\n\",\n    \"reachy.l_arm.goto([0, 0, 15, -90, 0, 0, 15], duration = 3)  #3\\n\",\n    \"reachy.r_arm.goto([0, 0, -15, -90, 0, 0, -15], duration = 2)  #4\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"40\",\n   \"metadata\": {},\n   \"source\": [\n    \"This sequence will still take 8 seconds to execute:\\n\",\n    \"- commands #1, #2 and #3 are sent to the left arm. They will be stacked on the left arm, and the `time.sleep(1)` won't have any effect . When received, command #2 will simply wait 2 seconds rather than 3 secondes in the previous example.\\n\",\n    \"- commands #4 is sent on the right arm, where no movement is processed. It will then start 1 second after command #1 has started, and will then be over approximatively at the same time.\\n\",\n    \"\\n\",\n    \"The sequence execution order is #1, #4, #2, #3.\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"41\",\n   \"metadata\": {},\n   \"source\": [\n    \"So how can a left arm goto wait for a right arm move? That's simple using the parameter *wait* in goto functions ! \\n\",\n    \"\\n\",\n    \"### Wait parameter\\n\",\n    \"\\n\",\n    \"As you could see earlier in the goto_posture() command, we can set the parameter *wait = True* in goto functions for the execution of the program to wait for the end of the movement before going on. \\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"1febf9c7\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default', wait = True)\\n\",\n    \"print('Default posture : done')\\n\",\n    \"r_goto_1 = reachy.r_arm.goto([0, 5, -15, -90, 0, 0, -10], duration = 2, wait = True)\\n\",\n    \"print('Right move : done')\\n\",\n    \"r_goto_2 = reachy.l_arm.goto([0, -5, 15, -90, 0, 0, 10], duration = 2, wait = True)\\n\",\n    \"print('Left move : done')\\n\",\n    \"reachy.goto_posture('default', wait = True)\\n\",\n    \"print('Default posture : done')\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"42\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Goto state\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"43\",\n   \"metadata\": {},\n   \"source\": [\n    \"For a specific goto, you may want to know its current state. You can get information on the goto given its id with 2 methods available at reachy's level:\\n\",\n    \"\\n\",\n    \"- **`is_goto_finished()`**: return True if the movement is over, but also if it won't be played because it has been cancelled for example\\n\",\n    \"- **`get_goto_joints_request()`**: will return the joints goal positions sent to the part by the corresponding goto command \\n\",\n    \"\\n\",\n    \"\\n\",\n    \"Let's take an example:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"44\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"goto_1 = reachy.l_arm.goto([0, 0, 0, -60, 0, 0, 0], duration = 3)\\n\",\n    \"\\n\",\n    \"time.sleep(1)\\n\",\n    \"\\n\",\n    \"# Goto is currently being played\\n\",\n    \"goto1_is_finished = reachy.is_goto_finished(goto_1)\\n\",\n    \"print(f'After 1 second, goto 1 is finished : {goto1_is_finished}\\\\n')\\n\",\n    \"\\n\",\n    \"time.sleep(3)\\n\",\n    \"\\n\",\n    \"# Goto is now over\\n\",\n    \"goto1_is_finished = reachy.is_goto_finished(goto_1)\\n\",\n    \"print(f'After 4 seconds, goto 1 is finished : {goto1_is_finished}')\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"45\",\n   \"metadata\": {},\n   \"source\": [\n    \"Retrieve the joint requests of a goto command from its ID:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"46\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.get_goto_joints_request(goto_1)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"47\",\n   \"metadata\": {},\n   \"source\": [\n    \"You get information on the part involved, the target joint values, the duration of the movement, and the interpolation mode. \"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"51\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Part execution state\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"52\",\n   \"metadata\": {},\n   \"source\": [\n    \"As the sequence can become complex, you can get information for each part on its current status, to know which movement is being played and know which others are waiting to be played.  \\n\",\n    \"For each part, the following methods are available:\\n\",\n    \"- **`get_goto_playing()`**: will return the id of the currently played goto on the part\\n\",\n    \"- **`get_goto_queue()`**: will return the ids of all stacked goto commands waiting to be played on the part\\n\",\n    \"\\n\",\n    \"Those methods are called at the part level, to get info on the state of the part.  \\n\",\n    \"\\n\",\n    \"Let's take an example. \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"53\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Write a sequence for the left arm\\n\",\n    \"goto_1 = reachy.l_arm.goto([0, -15, 15, -90, 0, 0, 0], duration = 3)\\n\",\n    \"goto_2 = reachy.l_arm.goto([0, -10, 0, 0, 0, 0, 0], duration = 2)\\n\",\n    \"goto_3 = reachy.l_arm.goto([0, -15, 15, -90, 0, 0, 0], duration = 3)\\n\",\n    \"\\n\",\n    \"print(f'goto 1: {goto_1.id}, goto 2: {goto_2.id}, goto 3: {goto_3.id}')\\n\",\n    \"\\n\",\n    \"# Goto #1 is currently playing\\n\",\n    \"current_goto = reachy.l_arm.get_goto_playing()\\n\",\n    \"print(f'current goto : {current_goto.id}')\\n\",\n    \"print(f'l_arm queue length: {len(reachy.l_arm.get_goto_queue())} gotos waiting to be played.')\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"57\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Goto cancellation\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"58\",\n   \"metadata\": {},\n   \"source\": [\n    \"If you want to modify the queue of goto commands on a part, or interrupt the movement being played, you can cancel goto commands at any time.  \"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"59\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Single goto cancellation\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"60\",\n   \"metadata\": {},\n   \"source\": [\n    \"To cancel a single movement, currently playing or stacked in a part's queue, use its id and call `cancel_goto_by_id()` from reachy. It will stop the robot at its current position.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"61\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default', wait = True)\\n\",\n    \"goto_1 = reachy.l_arm.goto([0, 15, 15, -90, 10, 0, 0], duration = 3)\\n\",\n    \"goto_2 = reachy.head.goto([30, 0, 0], duration = 3)\\n\",\n    \"\\n\",\n    \"time.sleep(1)\\n\",\n    \"reachy.cancel_goto_by_id(goto_1)\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"62\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Multiple gotos cancellation\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"63\",\n   \"metadata\": {},\n   \"source\": [\n    \"To cancel all gotos at once, you can call the `cancel_all_goto()` methods.  \\n\",\n    \"This method can be called at the level you want to act, which can be either **reachy** or a **specific part**. \"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"64\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### All gotos\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"65\",\n   \"metadata\": {},\n   \"source\": [\n    \"For example, if you want to cancel all gotos on all parts:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"66\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default', wait = True)\\n\",\n    \"\\n\",\n    \"# Send a sequence of gotos\\n\",\n    \"reachy.head.goto([20, 30, -10], duration = 3)\\n\",\n    \"reachy.l_arm.goto([0, 0, 0, -90, 0, 0, 0], duration = 3)\\n\",\n    \"reachy.l_arm.goto([0, 0, 0, 0, 0, 0, 0], duration = 3)\\n\",\n    \"\\n\",\n    \"time.sleep(1.5)\\n\",\n    \"\\n\",\n    \"# Cancel all gotos\\n\",\n    \"reachy.cancel_all_goto()\\n\",\n    \"\\n\",\n    \"print(f\\\"Length of l_arm goto queue : {len(reachy.l_arm.get_goto_queue())}\\\")\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"67\",\n   \"metadata\": {},\n   \"source\": [\n    \"All movements are cancelled, even the movement stacked in the left arm queue which will never be played.  \"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"68\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### All gotos for one part\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"69\",\n   \"metadata\": {},\n   \"source\": [\n    \"If you only want to cancel movement on the left arm:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"70\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default', wait = True)\\n\",\n    \"\\n\",\n    \"# Send a sequence of gotos\\n\",\n    \"reachy.head.goto([20, 30, -10], duration=3)\\n\",\n    \"reachy.l_arm.goto([0, 0, 0, -90, 0, 0, 0], duration = 3)\\n\",\n    \"reachy.l_arm.goto([0, 0, 0, 0, 0, 0, 0], duration = 2)\\n\",\n    \"\\n\",\n    \"time.sleep(1)\\n\",\n    \"\\n\",\n    \"# Cancel gotos on left arm only\\n\",\n    \"reachy.l_arm.cancel_all_goto()\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"71\",\n   \"metadata\": {},\n   \"source\": [\n    \"The movement on the head will continue, but all the movements of the left will be stopped and the left arm queue cleaned.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"72\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.goto_posture('default', wait=True)\\n\",\n    \"reachy.turn_off()\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"reachy10\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.10.14\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n"
  },
  {
    "type": "tutorial",
    "name": "4_head_control.ipynb",
    "path": "4_head_control.ipynb",
    "content": "{\n \"cells\": [\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"0\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Head control\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"1\",\n   \"metadata\": {},\n   \"source\": [\n    \"Reachy 2's head is mounted on an Orbita3D actuator, referred to as the **neck** actuator, giving 3 degrees of freedom to control the head orientation.  \\n\",\n    \"\\n\",\n    \"Before starting to control the head, connect to your Reachy and turn it on.\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"2\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Initialize your robot\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"3\",\n   \"metadata\": {},\n   \"source\": [\n    \"First connect to your robot:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"4\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from reachy2_sdk import ReachySDK\\n\",\n    \"\\n\",\n    \"reachy = ReachySDK(host='localhost')  # Replace with the actual IP address\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"5\",\n   \"metadata\": {},\n   \"source\": [\n    \"Let's check what contains the head part:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"6\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.head.joints\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"7\",\n   \"metadata\": {},\n   \"source\": [\n    \"As you can see, the head is composed of **three joints**:\\n\",\n    \"- neck.roll\\n\",\n    \"- neck.pitch\\n\",\n    \"- neck.yaw\\n\",\n    \"\\n\",\n    \"All joints belong to the same Orbita3D actuator, referred to as the **neck**.\\n\",\n    \"\\n\",\n    \"To start, we need to turn the head on:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"8\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.head.turn_on()\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"9\",\n   \"metadata\": {},\n   \"source\": [\n    \"You could of course turn on the whole robot by calling `reachy.turn_on()` directly.\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"10\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Head goto\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"11\",\n   \"metadata\": {},\n   \"source\": [\n    \"There are several ways to control the head movements:\\n\",\n    \"- using the `look_at()`, `goto` and `rotate_by` methods, called directly at the **head** level. These methods work as in the [goto_introduction](2_goto_introduction.ipynb) example\\n\",\n    \"- controlling the joints goal positions, namely **reachy.head.neck.roll**, **reachy.head.neck.pitch** and **reachy.head.neck.yaw**.\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"12\",\n   \"metadata\": {},\n   \"source\": [\n    \"### look_at()\\n\",\n    \"\\n\",\n    \"You can use the `look_at()` function to make the head look at a specific point in space. This point must be given in Reachy 2's coordinate system in **meters**. The coordinate system is the one we have seen previously:\\n\",\n    \"\\n\",\n    \"* the X axis corresponds to the forward arrow,\\n\",\n    \"* the Y axis corresponds to the right to left arrow,\\n\",\n    \"* the Z axis corresponds to the up arrow.\\n\",\n    \"\\n\",\n    \"The origin of this coordinate system is located in the upper part of the robot trunk.\\n\",\n    \"\\n\",\n    \"If you want Reachy to look forward, you can send it the following.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"13\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.head.look_at(x=0.5, y=0, z=0.2, duration=1.0, wait = True)\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"14\",\n   \"metadata\": {},\n   \"source\": [\n    \"You can use multiple *look_at* to chain head movements, or even chain them with the `goto()` function described below. As seen in the goto tutorial, the commands on the head will be stacked.\\n\",\n    \"For example:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"15\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"import time\\n\",\n    \"\\n\",\n    \"look_right = reachy.head.look_at(x=0.5, y=-0.3, z=0.1, duration=1.0)\\n\",\n    \"look_down = reachy.head.look_at(x=0.5, y=0, z=-0.4, duration=1.0)\\n\",\n    \"look_left = reachy.head.look_at(x=0.5, y=0.3, z=-0.1, duration=1.0)\\n\",\n    \"look_front = reachy.head.look_at(x=0.5, y=0, z=0, duration=1.0)\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"16\",\n   \"metadata\": {},\n   \"source\": [\n    \"The best way to understand how to use the *look_at* is to play with it. Picture a position you would like Reachy's head to be in, guess a point which could match for the *look_at* and check if you got it right!\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"17\",\n   \"metadata\": {},\n   \"source\": [\n    \"### goto()\\n\",\n    \"\\n\",\n    \"The `goto()` function is another way to control the head. There is two ways to use it :\\n\",\n    \"- from the desired orientation as a quaternion (in cartesian space)\\n\",\n    \"- from joints positions (in joint space)\\n\",\n    \"\\n\",\n    \"So, you give either a quaternion or a list of 3 degree values.\\n\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"19\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### In cartesian space\\n\",\n    \"\\n\",\n    \"You can control the head with a quaternion, in cartesian space.\\n\",\n    \"\\n\",\n    \"You can use [pyquaternion library](https://kieranwynn.github.io/pyquaternion/) to create suitable quaternion for this method.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"20\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from pyquaternion import Quaternion\\n\",\n    \"\\n\",\n    \"q = Quaternion(axis=[1, 0, 0], angle=3.14159265 / 4) # tilt head about 45\u00b0 to the right\\n\",\n    \"reachy.head.goto(q)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"64afc46e\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### In joint space\\n\",\n    \"\\n\",\n    \" You can directly control the joint value of the neck, giving the roll, pitch and yaw angles in degrees. The rotation is made in the order: roll, pitch, yaw, in the Orbita3D coordinate system.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"624f4dfe\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.head.goto([15, -20, 0], duration=1.0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"2b588f71\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Rotate_by()\\n\",\n    \"\\n\",\n    \"You can also control the head from its current position, by using the *rotate_by* function and specifying angular degree values in roll, pitch, yaw, either in Reachy's or head's frame. \\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"d23ff45f\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.head.rotate_by(roll=0, pitch=0, yaw=20, frame='head')\\n\",\n    \"\\n\",\n    \"reachy.head.rotate_by(roll=-30, pitch=0, yaw=0, frame='robot')\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"21\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Read head position\\n\",\n    \"\\n\",\n    \"You can read the head positions using : \\n\",\n    \"\\n\",\n    \"- Cartesian space : \\n\",\n    \"> `get_current_orientation()` will give the orientation as a quaternion\\n\",\n    \"\\n\",\n    \"\\n\",\n    \"- Joint space :  \\n\",\n    \"> `get_current_positions()` will give the neck's roll, pitch and yaw present_position\\n\",\n    \"\\n\",\n    \"### In cartesian space :\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"22\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"q = reachy.head.get_current_orientation()\\n\",\n    \"print(q)\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"23\",\n   \"metadata\": {},\n   \"source\": [\n    \"### In joint space : \\n\",\n    \"\\n\",\n    \"In case you feel more comfortable using roll, pitch, yaw angles rather than working with quaternions, you can retrieve those values from the **neck joints**.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"24\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.head.goto([20, 20, -10], wait = True)\\n\",\n    \"\\n\",\n    \"reachy.head.get_current_positions()\"\n   ]\n  },\n  {\n   \"attachments\": {},\n   \"cell_type\": \"markdown\",\n   \"id\": \"29\",\n   \"metadata\": {},\n   \"source\": [\n    \"Then, you can reset the head to default position and turn it off.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"30\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.head.goto_posture(common_posture=\\\"default\\\", wait=True)\\n\",\n    \"    \\n\",\n    \"reachy.turn_off_smoothly()\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"reachy10\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.10.14\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n"
  },
  {
    "type": "tutorial",
    "name": "1_getting_started.ipynb",
    "path": "1_getting_started.ipynb",
    "content": "{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"0\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Getting started with Reachy 2\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"1\",\n   \"metadata\": {},\n   \"source\": [\n    \"In this first tutorial, we will familiarize ourselves with Reachy. We will cover how to connect to the robot and obtain basic information.\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"2\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Connect to Reachy\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"3\",\n   \"metadata\": {},\n   \"source\": [\n    \"First, establish a connection to your robot:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"4\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from reachy2_sdk import ReachySDK\\n\",\n    \"\\n\",\n    \"reachy = ReachySDK(host='localhost')  # Replace localhost with your robot's IP address\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"5\",\n   \"metadata\": {},\n   \"source\": [\n    \"You can check the connection status at any time with:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"6\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.is_connected()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"7\",\n   \"metadata\": {},\n   \"source\": [\n    \"Reachy is now ready for use. By default, all motors are turned off. In the next tutorial, we will learn how to move Reachy. The overall status of Reachy's motors can be checked as follows:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"8\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.is_on() # will return False because the motors are off by default\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"9\",\n   \"metadata\": {},\n   \"source\": [\n    \"Let's retrieve information about the robot, including mode, serial number, hardware / software versions, and battery level:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"10\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.info\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"11\",\n   \"metadata\": {},\n   \"source\": [\n    \"You can also access these informations independently, for example:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"12\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.info.battery_voltage\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"13\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Body parts\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"14\",\n   \"metadata\": {},\n   \"source\": [\n    \"Let's take a look at Reachy's body. Reachy's arm has 7 degrees of freedom and one joint for the gripper.\\n\",\n    \"\\n\",\n    \"The **arm** is divided into the following parts:\\n\",\n    \"- **shoulder**, consisting of 2 joints (pitch and roll)\\n\",\n    \"- **elbow**, consisting of 2 joints (yaw and pitch)\\n\",\n    \"- **wrist**, consisting of 3 joints (roll, pitch, and yaw)\\n\",\n    \"\\n\",\n    \"We refer to the shoulder, elbow, and wrist as **actuators**. A joint is essentially an axis along which the actuator can rotate.\\n\",\n    \"For some actions, such as changing the compliancy, this is the lowest level of control you will have.\\n\",\n    \"\\n\",\n    \"The head consists of one actuator, the **neck**, with 3 degrees of freedom (joints).\\n\",\n    \"\\n\",\n    \"The following command lists all available joints:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"15\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.joints\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"16\",\n   \"metadata\": {},\n   \"source\": [\n    \"The current and goal positions are also listed (i.e., the present and target angles of the joints).\\n\",\n    \"Each body part can be explored individually:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"17\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.r_arm.joints\\n\",\n    \"#reachy.l_arm.joints\\n\",\n    \"#reachy.head.joints\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"18\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Mobile Base\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"19\",\n   \"metadata\": {},\n   \"source\": [\n    \"The mobile base can be accessed in the same way as the body parts:\\n\",\n    \"> Be aware that there is no mobile base in the fake mode configuration. \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"20\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.mobile_base\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"21\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Disconnect\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"22\",\n   \"metadata\": {},\n   \"source\": [\n    \"No action is required; simply close your terminal or notebook!\\n\",\n    \"\\n\",\n    \"If you need to switch between robots, you can disconnect from one and then connect to another:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"23\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.disconnect()\\n\",\n    \"\\n\",\n    \"reachy = ReachySDK(host='localhost') # connect to a new robot with its IP address\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"sdkv2\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.10.15\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n"
  },
  {
    "type": "tutorial",
    "name": "7_mobile_base.ipynb",
    "path": "7_mobile_base.ipynb",
    "content": "{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"0\",\n   \"metadata\": {},\n   \"source\": [\n    \"# The mobile base\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"1\",\n   \"metadata\": {},\n   \"source\": [\n    \"Reachy 2 is mounted on a mobile base!\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"2\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Initialize your robot\\n\",\n    \"\\n\",\n    \"First connect to your robot:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"3\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from reachy2_sdk import ReachySDK\\n\",\n    \"\\n\",\n    \"reachy = ReachySDK(host='localhost')  # Replace with the actual IP\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"4\",\n   \"metadata\": {},\n   \"source\": [\n    \"Let's check what contains the mobile base part:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"5\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.mobile_base\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"6\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Move around\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"7\",\n   \"metadata\": {},\n   \"source\": [\n    \"Three modes are possible to control the mobile base:\\n\",\n    \"- **goto** : move the mobile base to a target point in space -> use a *goto function* to get in this mode\\n\",\n    \"- **free wheel**: unlock the wheel so Reachy can be manually moved around easily -> *turn_off() method* will set this mode\\n\",\n    \"- **brake**: stop the movement and lock the wheels -> *turn_on() method* will set this mode\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"8\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Goto and odometry\\n\",\n    \"\\n\",\n    \"The goto function is used to place the mobile_base at a relative position and orientation to its odometry, set when the robot is switched on. To be sure, you can reset the odometry before calling the function. \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"9\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.mobile_base.turn_on()\\n\",\n    \"\\n\",\n    \"reachy.mobile_base.reset_odometry()\\n\",\n    \"\\n\",\n    \"# Move 20 cm forward\\n\",\n    \"reachy.mobile_base.goto(x=0.2, y=0.0, theta=0.0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"c38af9b8\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.mobile_base.goto(x=0.2, y=0.0, theta=0)\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"a45b5c1d\",\n   \"metadata\": {},\n   \"source\": [\n    \"If you want to move forward again the robot, you need to increase the x value.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"d9d9a743\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"import time\\n\",\n    \"\\n\",\n    \"reachy.mobile_base.goto(x=0.2, y=0.0, theta=0.0) #that won't do anything as the robot is already there\\n\",\n    \"time.sleep(2)\\n\",\n    \"\\n\",\n    \"# Move again 20cm forward\\n\",\n    \"reachy.mobile_base.goto(x=0.4, y=0.0, theta=0.0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"62686da7\",\n   \"metadata\": {},\n   \"source\": [\n    \"That's the same for the rotation. You can go back to the initial position than rotate the mobile base. \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"7f04c56e\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Go back to the initial position\\n\",\n    \"reachy.mobile_base.goto(x=0.0, y=0.0, theta=0.0)\\n\",\n    \"\\n\",\n    \"time.sleep(2)\\n\",\n    \"\\n\",\n    \"# Rotation to be at 90 degrees in the frame\\n\",\n    \"reachy.mobile_base.goto(x=0.0, y=0.0, theta=90.0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"10\",\n   \"metadata\": {},\n   \"source\": [\n    \"> Be careful, goto is not a *Goto* method as for the arms. It's a blocking function, meaning that the move needs to be finished before the rest of the code starts to execute. So, the goto id will return once the movement is done, or the timeout expired. If you need to run this function in parallel to other processing, please check the `goto_async`\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"11\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Go back to 0 degree in the frame\\n\",\n    \"reachy.mobile_base.goto(x=0.0, y=0.0, theta=0.0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"12\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Rotation to be at 90 degrees in the frame\\n\",\n    \"reachy.mobile_base.goto(x=0.0, y=0.0, theta=90.0)\\n\",\n    \"\\n\",\n    \"# Reset odometry\\n\",\n    \"reachy.mobile_base.reset_odometry()\\n\",\n    \"# Go back to 0 degree in the frame : it won't move because the frame has changed\\n\",\n    \"reachy.mobile_base.goto(x=0.0, y=0.0, theta=0.0)\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"13\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"# Rotation to be at -90 degrees in the new frame\\n\",\n    \"reachy.mobile_base.goto(x=0.0, y=0.0, theta=-90.0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"9c16bbed\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### Rotate_by / Translate_by\\n\",\n    \"\\n\",\n    \"You can also decide to assign movements to the robot based on its current position and not on its odometry. \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"096afcae\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.mobile_base.get_current_odometry()\\n\",\n    \"reachy.mobile_base.translate_by(x = 0.2, y = 0.0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"df8caec0\",\n   \"metadata\": {},\n   \"source\": [\n    \"You can do it again, to move the robot by 0.2m in the x direction.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"a9bd95f5\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.mobile_base.translate_by(x = 0.2, y = 0.0)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"5c56e122\",\n   \"metadata\": {},\n   \"source\": [\n    \"Now, the mobile base can be rotated 90\u00b0 from its current position, allowing to get a odometry with a theta = 0\u00b0. \"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"84e18a9f\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.mobile_base.rotate_by(theta = 90.0)\\n\",\n    \"reachy.mobile_base.get_current_odometry()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"14\",\n   \"metadata\": {},\n   \"source\": [\n    \"The speed of the movement can be defined using this command : *this will assign speed to the robot for 200ms*\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"15\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.mobile_base.set_goal_speed(x=1.0, y=1.0, theta=2)\\n\",\n    \"reachy.mobile_base.send_speed_command()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"16\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Free wheel\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"17\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.mobile_base.turn_off()\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"sdkv2\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.10.15\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n"
  },
  {
    "type": "tutorial",
    "name": "5_cameras_images.ipynb",
    "path": "5_cameras_images.ipynb",
    "content": "{\n \"cells\": [\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"0\",\n   \"metadata\": {},\n   \"source\": [\n    \"# Get images from cameras\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"2\",\n   \"metadata\": {},\n   \"source\": [\n    \"Reachy 2 has 2 types of camera:\\n\",\n    \"\\n\",\n    \"- the **teleop** cameras, with a right and left cameras, located in Reachy 2\u2019s head and used for the teleoperation\\n\",\n    \"- the **depth** camera, equipped with a depth sensor, located in Reachy 2\u2019s torso and mainly useful for manipulation tasks\\n\",\n    \"\\n\",\n    \"Each camera can be accessed separately through reachy.cameras. Teleop cameras  have a right and left view, with the left and right sides considered from Reachy point of view, while the depth camera has a left (i.e. mono RGB) and depth view. To be able to specify the view you want to get a frame from, you will need to import CameraView:\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"3\",\n   \"metadata\": {},\n   \"source\": [\n    \"```python\\n\",\n    \"from reachy2_sdk.media.camera import CameraView\\n\",\n    \"```\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"4\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Get images\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"5\",\n   \"metadata\": {},\n   \"source\": [\n    \"First, connect to your robot.  \\n\",\n    \"**Do not forget to import the CameraView!**\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"6\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from reachy2_sdk.media.camera import CameraView\\n\",\n    \"from reachy2_sdk import ReachySDK\\n\",\n    \"\\n\",\n    \"reachy = ReachySDK(host='localhost')  # Replace with the actual IP\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"7\",\n   \"metadata\": {},\n   \"source\": [\n    \"Check the list of initialized cameras:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"8\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"reachy.cameras\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"9\",\n   \"metadata\": {},\n   \"source\": [\n    \"The list of initialized cameras should contain both the teleop and depth cameras.  \"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"10\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Teleop cameras\\n\",\n    \"\\n\",\n    \"To get both views of the robot teleop cameras:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"11\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"l_frame, l_ts = reachy.cameras.teleop.get_frame(CameraView.LEFT)\\n\",\n    \"r_frame, r_ts = reachy.cameras.teleop.get_frame(CameraView.RIGHT)\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"12\",\n   \"metadata\": {},\n   \"source\": [\n    \"We can print the timestamp of each frame (in nanosecond)\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"13\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"print(f\\\"timestamp left frame {l_ts} - timestamp right frame {r_ts}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"14\",\n   \"metadata\": {},\n   \"source\": [\n    \"Let's display the captured frame with PIL:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"15\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"from PIL import Image\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"16\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"Image.fromarray(l_frame[:,:,::-1])\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"18\",\n   \"metadata\": {},\n   \"source\": [\n    \"The camera parameters, as defined [here](https://docs.ros.org/en/melodic/api/sensor_msgs/html/msg/CameraInfo.html), are also available\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"19\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"height, width, distortion_model, D, K, R, P =  reachy.cameras.teleop.get_parameters(CameraView.LEFT)\\n\",\n    \"print(f\\\"height: {height}\\\")\\n\",\n    \"print(f\\\"width: {width}\\\")\\n\",\n    \"print(f\\\"distortion model: {distortion_model}\\\")\\n\",\n    \"print(f\\\"distortion coefficients {D}\\\")\\n\",\n    \"print(f\\\"instrinsic matrix {K}\\\")\\n\",\n    \"print(f\\\"rectification matrix {R}\\\")\\n\",\n    \"print(f\\\"projection matrix {P}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"20\",\n   \"metadata\": {},\n   \"source\": [\n    \"### Depth camera\\n\",\n    \"\\n\",\n    \"The depth camera works exactly the same as the teleop camera, but you have more elements captured. In fact, it's a RGBD camera, so you have both access to the RGB image and depth information.\\n\",\n    \"\\n\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"21\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### RGB images\\n\",\n    \"\\n\",\n    \"Getting RGB images from the depth camera looks the same as from the teleop one:  simply use `get_frame()`, there is only one view.\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"22\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"frame, ts = reachy.cameras.depth.get_frame()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"23\",\n   \"metadata\": {},\n   \"source\": [\n    \"Let's display the captured frame with PIL:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"24\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"Image.fromarray(frame[:,:,::-1])\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"25\",\n   \"metadata\": {},\n   \"source\": [\n    \"As for the teleop camera, parameters are also availables\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"26\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"height, width, distortion_model, D, K, R, P =  reachy.cameras.depth.get_parameters()\\n\",\n    \"print(f\\\"height: {height}\\\")\\n\",\n    \"print(f\\\"width: {width}\\\")\\n\",\n    \"print(f\\\"distortion model: {distortion_model}\\\")\\n\",\n    \"print(f\\\"distortion coefficients {D}\\\")\\n\",\n    \"print(f\\\"instrinsic matrix {K}\\\")\\n\",\n    \"print(f\\\"rectification matrix {R}\\\")\\n\",\n    \"print(f\\\"projection matrix {P}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"27\",\n   \"metadata\": {},\n   \"source\": [\n    \"#### Depth information\\n\",\n    \"\\n\",\n    \"The SR camera is a depth camera, you can then diplay a left or right **depth frame** using `get_depth_frame()`, but also the **depthmap** and the **disparity**.   \\n\",\n    \"\\n\",\n    \"You first have to capture all, then you can read the frame and get the information you want:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"28\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"depth_frame, ts = reachy.cameras.depth.get_depth_frame()\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"29\",\n   \"metadata\": {},\n   \"source\": [\n    \"Let's display the captured frame with PIL:\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"30\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"Image.fromarray(depth_frame[:,:])\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"31\",\n   \"metadata\": {},\n   \"source\": [\n    \"If needed, camera parameters for the depth view are also available\"\n   ]\n  },\n  {\n   \"cell_type\": \"code\",\n   \"execution_count\": null,\n   \"id\": \"32\",\n   \"metadata\": {},\n   \"outputs\": [],\n   \"source\": [\n    \"height, width, distortion_model, D, K, R, P =  reachy.cameras.depth.get_parameters(CameraView.DEPTH)\\n\",\n    \"print(f\\\"height: {height}\\\")\\n\",\n    \"print(f\\\"width: {width}\\\")\\n\",\n    \"print(f\\\"distortion model: {distortion_model}\\\")\\n\",\n    \"print(f\\\"distortion coefficients {D}\\\")\\n\",\n    \"print(f\\\"instrinsic matrix {K}\\\")\\n\",\n    \"print(f\\\"rectification matrix {R}\\\")\\n\",\n    \"print(f\\\"projection matrix {P}\\\")\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"33\",\n   \"metadata\": {},\n   \"source\": [\n    \"## Live stream\"\n   ]\n  },\n  {\n   \"cell_type\": \"markdown\",\n   \"id\": \"34\",\n   \"metadata\": {},\n   \"source\": [\n    \"Although we provide an optimal way to get the video stream, it is still possible to display what Reachy see through the SDK. It could be useful to feed a compute vision algorithm that do not need to run at high frequency.\\n\",\n    \"\\n\",\n    \"This is demonstrated in a dedicated script : [cameras.py](cameras.py)\"\n   ]\n  }\n ],\n \"metadata\": {\n  \"kernelspec\": {\n   \"display_name\": \"reachy10\",\n   \"language\": \"python\",\n   \"name\": \"python3\"\n  },\n  \"language_info\": {\n   \"codemirror_mode\": {\n    \"name\": \"ipython\",\n    \"version\": 3\n   },\n   \"file_extension\": \".py\",\n   \"mimetype\": \"text/x-python\",\n   \"name\": \"python\",\n   \"nbconvert_exporter\": \"python\",\n   \"pygments_lexer\": \"ipython3\",\n   \"version\": \"3.10.14\"\n  }\n },\n \"nbformat\": 4,\n \"nbformat_minor\": 5\n}\n"
  }
]