[
  {
    "type": "module",
    "name": "reachy2_sdk.__init__",
    "docstring": "ReachySDK package.\n\nThis package provides remote access (via socket) to a Reachy robot.\nIt automatically handles the synchronization with the robot.\nIn particular, you can easily get an always up-to-date robot state (joint positions, sensors value).\nYou can also send joint commands, compute forward or inverse kinematics.\n\nSimply do\n```python\nfrom reachy2_sdk.reachy_sdk import ReachySDK\nreachy = ReachySDK(host=\"ip_address\")\n```\n\nAnd you're ready to use Reachy!\n\n*Examples are available [here](https://github.com/pollen-robotics/reachy2-sdk/tree/develop/src/examples)\n and tutorials [there](https://github.com/pollen-robotics/reachy2-tutorials) !*",
    "source": "__init__"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.reachy_sdk",
    "docstring": "ReachySDK package.\n\nThis package provides remote access (via socket) to a Reachy robot.\nIt automatically handles the synchronization with the robot.\nIn particular, you can easily get an always up-to-date robot state (joint positions, sensors value).\nYou can also send joint commands, compute forward or inverse kinematics.",
    "source": "reachy_sdk"
  },
  {
    "type": "class",
    "name": "ReachySDK",
    "module": "reachy2_sdk.reachy_sdk",
    "docstring": "The ReachySDK class manages the connection and interaction with a Reachy robot.\n\nThis class handles:\n- Establishing and maintaining a connection with the robot via gRPC.\n- Accessing and controlling various parts of the robot, such as the arms, head, and mobile base.\n- Managing robot components including actuators, joints, cameras, and audio.\n- Synchronizing robot state with the server in the background to keep data up-to-date.\n- Providing utility functions for common tasks such as turning on/off motors, sending goal positions,\n    and performing movements.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, host: str, sdk_port: int, audio_port: int, video_port: int) -> None",
        "docstring": "Initialize a connection to the robot.\n\nArgs:\n    host: The IP address or hostname of the robot.\n    sdk_port: The gRPC port for the SDK. Default is 50051.\n    audio_port: The gRPC port for audio services. Default is 50063.\n    video_port: The gRPC port for video services. Default is 50065.",
        "source_code": " Reachy robot.\nIt automatically handles",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "host": "str",
          "sdk_port": "int",
          "audio_port": "int",
          "video_port": "int"
        }
      },
      {
        "name": "connect",
        "signature": "(self) -> None",
        "docstring": "Connects the SDK to the robot.",
        "source_code": "the synchronization with the robot",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "disconnect",
        "signature": "(self, lost_connection: bool) -> None",
        "docstring": "Disconnect the SDK from the robot's server.\n\nArgs:\n    lost_connection: If `True`, indicates that the connection was lost unexpectedly.",
        "source_code": "\nIn particular, you can",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "lost_connection": "bool"
        }
      },
      {
        "name": "info",
        "signature": "(self) -> Optional[ReachyInfo]",
        "docstring": "Get ReachyInfo if connected.",
        "source_code": " up-to",
        "return_type": "Optional[ReachyInfo]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "head",
        "signature": "(self) -> Optional[Head]",
        "docstring": "Get Reachy's head.",
        "source_code": "ate robot",
        "return_type": "Optional[Head]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "r_arm",
        "signature": "(self) -> Optional[Arm]",
        "docstring": "Get Reachy's right arm.",
        "source_code": "tate (joi",
        "return_type": "Optional[Arm]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "l_arm",
        "signature": "(self) -> Optional[Arm]",
        "docstring": "Get Reachy's left arm.",
        "source_code": " position",
        "return_type": "Optional[Arm]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "mobile_base",
        "signature": "(self) -> Optional[MobileBase]",
        "docstring": "Get Reachy's mobile base.",
        "source_code": " sensors ",
        "return_type": "Optional[MobileBase]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "joints",
        "signature": "(self) -> CustomDict[str, OrbitaJoint]",
        "docstring": "Return a dictionary of all joints of the robot.\n\nThe dictionary keys are the joint names, and the values are the corresponding OrbitaJoint objects.",
        "source_code": "lue).\nYou can ",
        "return_type": "CustomDict[str, OrbitaJoint]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_connected",
        "signature": "(self) -> bool",
        "docstring": "Check if the SDK is connected to the robot.\n\nReturns:\n    `True` if connected, `False` otherwise.",
        "source_code": "ommands",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "cameras",
        "signature": "(self) -> Optional[CameraManager]",
        "docstring": "Get the camera manager if available and connected.",
        "source_code": "nemati",
        "return_type": "Optional[CameraManager]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_update_timestamp",
        "signature": "(self) -> int",
        "docstring": "Returns the timestamp (ns) of the last update.\n\nThe timestamp is generated by ROS running on Reachy.\n\nReturns:\n    timestamp (int) in nanoseconds.",
        "source_code": "mixel_mot",
        "return_type": "int",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "audit",
        "signature": "(self) -> Dict[str, Dict[str, str]]",
        "docstring": "Return the audit status of all enabled parts of the robot.",
        "source_code": "s\n\nimport",
        "return_type": "Dict[str, Dict[str, str]]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "turn_on",
        "signature": "(self) -> bool",
        "docstring": "Activate all motors of the robot's parts if all of them are not already turned on.\n\nReturns:\n    `True` if successful, `False` otherwise.",
        "source_code": "threading\nimport time\nfrom collec",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "turn_off",
        "signature": "(self) -> bool",
        "docstring": "Turn all motors of enabled parts off.\n\nAll enabled parts' motors will then be compliant.",
        "source_code": "ions import nam",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "turn_off_smoothly",
        "signature": "(self) -> bool",
        "docstring": "Turn all motors of robot parts off.\n\nArm torques are reduced during 3 seconds, then all parts' motors will be compliant.",
        "source_code": "dtuple\nfrom logging import getLogger\nfro",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_on",
        "signature": "(self) -> bool",
        "docstring": "Check if all actuators of Reachy parts are on (stiff).\n\nReturns:\n    `True` if all are stiff, `False` otherwise.",
        "source_code": " typing import A",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_off",
        "signature": "(self) -> bool",
        "docstring": "Check if all actuators of Reachy parts are off (compliant).\n\nReturns:\n    `True` if all are compliant, `False` otherwise.",
        "source_code": "y, Dict, Optiona",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "reset_default_limits",
        "signature": "(self) -> None",
        "docstring": "Set back speed and torque limits of all parts to maximum value (100).",
        "source_code": "pe\n\nimport ",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "goto_posture",
        "signature": "(self, common_posture: str, duration: float, wait: bool, wait_for_goto_end: bool, interpolation_mode: str, open_gripper: bool) -> GoToHomeId",
        "docstring": "Move the robot to a predefined posture.\n\nArgs:\n    common_posture: The name of the posture. It can be 'default' or 'elbow_90'. Defaults to 'default'.\n    duration: The time duration in seconds for the robot to move to the specified posture.\n        Defaults to 2.\n    wait: Determines whether the program should wait for the movement to finish before\n        returning. If set to `True`, the program waits for the movement to complete before continuing\n        execution. Defaults to `False`.\n    wait_for_goto_end: Specifies whether commands will be sent to a part immediately or\n        only after all previous commands in the queue have been executed. If set to `False`, the program\n        will cancel all executing moves and queues. Defaults to `True`.\n    interpolation_mode: The type of interpolation used when moving the arm's joints.\n        Can be 'minimum_jerk' or 'linear'. Defaults to 'minimum_jerk'.\n    open_gripper: If `True`, the gripper will open, if `False`, it stays in its current position.\n        Defaults to `False`.\n\nReturns:\n    A GoToHomeId containing movement GoToIds for each part.",
        "source_code": "rpc\nfrom google.protobuf.empty_pb2 import Empty\nfrom google.protobuf",
        "return_type": "GoToHomeId",
        "parameters": {
          "self": "Any",
          "common_posture": "str",
          "duration": "float",
          "wait": "bool",
          "wait_for_goto_end": "bool",
          "interpolation_mode": "str",
          "open_gripper": "bool"
        }
      },
      {
        "name": "is_goto_finished",
        "signature": "(self, goto_id: GoToId) -> bool",
        "docstring": "Check if a goto command has completed.\n\nArgs:\n    goto_id: The unique GoToId of the goto command.\n\nReturns:\n    `True` if the command is complete, `False` otherwise.",
        "source_code": "timestamp_pb2 import Tim",
        "return_type": "bool",
        "parameters": {
          "self": "Any",
          "goto_id": "GoToId"
        }
      },
      {
        "name": "get_goto_joints_request",
        "signature": "(self, goto_id: GoToId) -> Optional[SimplifiedRequest]",
        "docstring": "Retrieve the details of a goto command based on its GoToId.\n\nArgs:\n    goto_id: The ID of the goto command for which details are requested.\n\nReturns:\n    A `SimplifiedRequest` object containing the part name, joint goal positions\n    (in degrees), movement duration, and interpolation mode.\n    Returns `None` if the robot is not connected or if the `goto_id` is invalid.\n\nRaises:\n    TypeError: If `goto_id` is not an instance of `GoToId`.\n    ValueError: If `goto_id` is -1, indicating an invalid command.",
        "source_code": "stamp\nfrom grpc._channel import _InactiveRpc",
        "return_type": "Optional[SimplifiedRequest]",
        "parameters": {
          "self": "Any",
          "goto_id": "GoToId"
        }
      },
      {
        "name": "cancel_goto_by_id",
        "signature": "(self, goto_id: GoToId) -> GoToAck",
        "docstring": "Request the cancellation of a specific goto command based on its GoToId.\n\nArgs:\n    goto_id: The ID of the goto command to cancel.\n\nReturns:\n    A `GoToAck` object indicating whether the cancellation was acknowledged.\n    If the robot is not connected, returns None.\n\nRaises:\n    TypeError: If `goto_id` is not an instance of `GoToId`.",
        "source_code": "achy2_sdk_api import re",
        "return_type": "GoToAck",
        "parameters": {
          "self": "Any",
          "goto_id": "GoToId"
        }
      },
      {
        "name": "cancel_all_goto",
        "signature": "(self) -> GoToAck",
        "docstring": "Cancel all active goto commands.\n\nReturns:\n     A `GoToAck` object indicating whether the cancellation was acknowledged.",
        "source_code": "chy_pb2, re",
        "return_type": "GoToAck",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "send_goal_positions",
        "signature": "(self, check_positions: bool) -> None",
        "docstring": "Send the goal positions to the robot.\n\nIf goal positions have been specified for any joint of the robot, sends them to the robot.\n\nArgs :\n    check_positions: A boolean indicating whether to check the positions after sending the command.\n        Defaults to True.",
        "source_code": "chy_pb2_grpc\nfro",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "check_positions": "bool"
        }
      }
    ],
    "source": "reachy2_sdk.reachy_sdk.ReachySDK"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.orbita.orbita_axis",
    "docstring": "Reachy OrbitaAxis module.\n\nHandles all specific methods to OrbitaAxis.",
    "source": "orbita.orbita_axis"
  },
  {
    "type": "class",
    "name": "OrbitaAxis",
    "module": "reachy2_sdk.orbita.orbita_axis",
    "docstring": "The OrbitaAxis class represents any Orbita3d or Orbita2d axis.\n\nThe OrbitaAxis class is used to store the up-to-date state of the axis, especially:\n- its present speed (RO)\n- its present load (RO)",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, initial_state: Dict[str, FloatValue]) -> None",
        "docstring": "Initialize the axis with its initial state.\n\nArgs:\n    initial_state: A dictionary containing the initial state values for the axis. The keys should include\n        \"present_speed\" and \"present_load\", with corresponding FloatValue objects as values.",
        "source_code": " module.",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "initial_state": "Dict[str, FloatValue]"
        }
      },
      {
        "name": "present_speed",
        "signature": "(self) -> float",
        "docstring": "Get the present speed of the axis in radians per second.",
        "source_code": "Han",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "present_load",
        "signature": "(self) -> float",
        "docstring": "Get the present load of the axis in Newtons.",
        "source_code": "es ",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      }
    ],
    "source": "reachy2_sdk.orbita.orbita_axis.OrbitaAxis"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.orbita.orbita",
    "docstring": "Reachy Orbita module.\n\nHandles all specific methods commmon to all Orbita2d and Orbita3d.",
    "source": "orbita.orbita"
  },
  {
    "type": "class",
    "name": "Orbita",
    "module": "reachy2_sdk.orbita.orbita",
    "docstring": "The Orbita class is an abstract class to represent any Orbita actuator.\n\nThe Orbita class is used to store the up-to-date state of the actuator, especially:\n- its compliancy\n- its joints state\n- its motors state\n- its axis state\n\nAnd apply speed, torque, pid and compliancy to all motors of the actuator.\n\nThis class is meant to be derived by Orbita2d and Orbita3d",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, uid: int, name: str, orbita_type: str, stub: Orbita2dServiceStub | Orbita3dServiceStub, part: Part)",
        "docstring": "Initialize the Orbita actuator with its common attributes.\n\nArgs:\n    uid: The unique identifier for the actuator.\n    name: The name of the actuator.\n    orbita_type: Specifies the type of Orbita, either \"2d\" or \"3d\".\n    stub: The gRPC stub used for communicating with the actuator, which can be an\n        instance of either `Orbita2dServiceStub` or `Orbita3dServiceStub`.\n    part: The parent part to which the Orbita belongs, used for referencing the\n        part's attributes.",
        "source_code": "fic methods commmon to all Orbi",
        "return_type": null,
        "parameters": {
          "self": "Any",
          "uid": "int",
          "name": "str",
          "orbita_type": "str",
          "stub": "Orbita2dServiceStub | Orbita3dServiceStub",
          "part": "Part"
        }
      },
      {
        "name": "set_speed_limits",
        "signature": "(self, speed_limit: float | int) -> None",
        "docstring": "Set the speed limits for the Orbita actuator.\n\nThis method defines the maximum speed for the joints, specified as a percentage\nof the maximum speed capability.\n\nArgs:\n    speed_limit: The desired speed limit as a percentage (0-100).\n\nRaises:\n    TypeError: If the provided speed_limit is not a float or int.\n    ValueError: If the provided speed_limit is outside the range [0, 100].",
        "source_code": "mport logging\nimp",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "speed_limit": "float | int"
        }
      },
      {
        "name": "set_torque_limits",
        "signature": "(self, torque_limit: float | int) -> None",
        "docstring": "Set the torque limits for the Orbita actuator.\n\nThis method defines the maximum torque for the joints, specified as a percentage\nof the maximum torque capability.\n\nArgs:\n    torque_limit: The desired torque limit as a percentage (0-100).\n\nRaises:\n    TypeError: If the provided torque_limit is not a float or int.\n    ValueError: If the provided torque_limit is outside the range [0, 100].",
        "source_code": "t time\nfrom abc i",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "torque_limit": "float | int"
        }
      },
      {
        "name": "get_speed_limits",
        "signature": "(self) -> Dict[str, float]",
        "docstring": "Get the speed limits for all motors of the actuator.\n\nThe speed limits are expressed as percentages of the maximum speed for each motor.\n\nReturns:\n    A dictionary where each key is the motor name and the value is the speed limit\n    percentage (0-100) for that motor. Motor names are of format \"motor_{n}\".",
        "source_code": " abstractm",
        "return_type": "Dict[str, float]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_torque_limits",
        "signature": "(self) -> Dict[str, float]",
        "docstring": "Get the torque limits for all motors of the actuator.\n\nThe torque limits are expressed as percentages of the maximum torque for each motor.\n\nReturns:\n    A dictionary where each key is the motor name and the value is the torque limit\n    percentage (0-100) for that motor. Motor names are of format \"motor_{n}\".",
        "source_code": "thod\nfrom ",
        "return_type": "Dict[str, float]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_pids",
        "signature": "(self) -> Dict[str, Tuple[float, float, float]]",
        "docstring": "Get the PID values for all motors of the actuator.\n\nEach motor's PID controller parameters (Proportional, Integral, Derivative) are returned.\n\nReturns:\n    A dictionary where each key is the motor name and the value is a tuple containing\n    the PID values (P, I, D) for that motor. Motor names are of format \"motor_{n}\".",
        "source_code": "hreading i",
        "return_type": "Dict[str, Tuple[float, float, float]]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "turn_on",
        "signature": "(self) -> None",
        "docstring": "Turn on all motors of the actuator.",
        "source_code": "por",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "turn_off",
        "signature": "(self) -> None",
        "docstring": "Turn off all motors of the actuator.",
        "source_code": " Th",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_on",
        "signature": "(self) -> bool",
        "docstring": "Check if the actuator is currently stiff.\n\nReturns:\n    `True` if the actuator is stiff (not compliant), `False` otherwise.",
        "source_code": "ead\nfro",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_off",
        "signature": "(self) -> bool",
        "docstring": "Check if the actuator is currently compliant.\n\nReturns:\n    `True` if the actuator is compliant (not stiff), `False` otherwise.",
        "source_code": " typing",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "temperatures",
        "signature": "(self) -> Dict[str, float]",
        "docstring": "Get the current temperatures of all the motors in the actuator.\n\nReturns:\n    A dictionary where each key is the motor name and the value is the\n    current temperature of the motor in degrees Celsius. Motor names are of format \"motor_{n}\".",
        "source_code": "mport An",
        "return_type": "Dict[str, float]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "send_goal_positions",
        "signature": "(self, check_positions: bool) -> None",
        "docstring": "Send the goal positions to the actuator.\n\nThis method is abstract and should be implemented in derived classes to\nsend the specified goal positions to the actuator's joints.\n\nArgs:\n    check_positions: A boolean value indicating whether to check the positions of the joints\n        after sending the goal positions. If `True`, a background thread is started to monitor\n        the joint positions relative to their last goal positions.\n        Default is `True`.",
        "source_code": "mpy as np\nfro",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "check_positions": "bool"
        }
      },
      {
        "name": "audit",
        "signature": "(self) -> Optional[str]",
        "docstring": "Get the current audit status of the actuator.\n\nReturns:\n    The audit status as a string, representing the latest error or status\n    message, or `None` if there is no error.",
        "source_code": "e\nfrom r",
        "return_type": "Optional[str]",
        "parameters": {
          "self": "Any"
        }
      }
    ],
    "source": "reachy2_sdk.orbita.orbita.Orbita"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.orbita.__init__",
    "docstring": "Orbita module.\n\nThis module manages the orbita actuators: axis, motors and joints.",
    "source": "orbita.__init__"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.orbita.orbita_joint",
    "docstring": "Reachy OrbitaJoint module.\n\nHandles all specific methods to OrbitaJoint.",
    "source": "orbita.orbita_joint"
  },
  {
    "type": "class",
    "name": "OrbitaJoint",
    "module": "reachy2_sdk.orbita.orbita_joint",
    "docstring": "The OrbitaJoint class represents any Orbita2d or Orbita3d joint.\n\nThe OrbitaJoint class is used to store the up-to-date state of the joint, especially:\n- its present_position (RO)\n- its goal_position (RW)",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, initial_state: Dict[str, FloatValue], axis_type: str, actuator: Any, position_order_in_part: int) -> None",
        "docstring": "Initialize the OrbitaJoint with its initial state and configuration.\n\nThis sets up the joint by assigning its actuator, axis type, and position order within\nthe part, and updates its state based on the provided initial values.\n\nArgs:\n    initial_state: A dictionary containing the initial state of the joint, with\n        each entry representing a specific parameter of the joint (e.g., present position).\n    axis_type: The type of axis for the joint (e.g., roll, pitch, yaw).\n    actuator: The actuator to which this joint belongs.\n    position_order_in_part: The position order of this joint in the overall part's\n        list of joints.",
        "source_code": " module.\n\nHandles all spe",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "initial_state": "Dict[str, FloatValue]",
          "axis_type": "str",
          "actuator": "Any",
          "position_order_in_part": "int"
        }
      },
      {
        "name": "present_position",
        "signature": "(self) -> float",
        "docstring": "Get the present position of the joint in degrees.",
        "source_code": " to",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "goal_position",
        "signature": "(self) -> float",
        "docstring": "Get the goal position of the joint in degrees.",
        "source_code": "rbi",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "goal_position",
        "signature": "(self, value: float | int) -> None",
        "docstring": "Set the goal position of the joint in degrees.\n\nThe goal position is not send to the joint immediately, it is stored locally until the `send_goal_positions` method\nis called.\n\nArgs:\n    value: The goal position to set, specified as a float or int.\n\nRaises:\n    TypeError: If the provided value is not a float or int.",
        "source_code": "Joint.\n\"\"\"\n\nfrom",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "value": "float | int"
        }
      },
      {
        "name": "goto",
        "signature": "(self, goal_position: float, duration: float, wait: bool, interpolation_mode: str, degrees: bool) -> GoToId",
        "docstring": "Send the joint to the specified goal position within a given duration.\n\nActs like a \"goto\" movement on the part, where \"goto\" movements for joints are queued on the part they belong to.\n\nArgs:\n    goal_position: The target position to move the joint to.\n    duration: The time in seconds for the joint to reach the goal position. Defaults to 2.\n    wait: Whether to wait for the movement to finish before continuing. Defaults to False.\n    interpolation_mode: The type of interpolation to use for the movement, either \"minimum_jerk\" or \"linear\".\n        Defaults to \"minimum_jerk\".\n    degrees: Whether the goal position is specified in degrees. If True, the position is interpreted as degrees.\n        Defaults to True.\n\nReturns:\n    The GoToId associated with the movement command.",
        "source_code": "typing import Any, Dict\n\nfrom google",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "goal_position": "float",
          "duration": "float",
          "wait": "bool",
          "interpolation_mode": "str",
          "degrees": "bool"
        }
      }
    ],
    "source": "reachy2_sdk.orbita.orbita_joint.OrbitaJoint"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.orbita.orbita2d",
    "docstring": "Reachy Orbita2d module.\n\nHandles all specific methods to Orbita2d.",
    "source": "orbita.orbita2d"
  },
  {
    "type": "class",
    "name": "Orbita2d",
    "module": "reachy2_sdk.orbita.orbita2d",
    "docstring": "The Orbita2d class represents any Orbita2d actuator and its joints, motors and axis.\n\nThe Orbita2d class is used to store the up-to-date state of the actuator, especially:\n- its compliancy\n- its joints state\n- its motors state\n- its axis state\n\nYou can access properties of the motors from the actuators with function that act on all the actuator's motors:\n- speed limit (in percentage, for all motors of the actuator)\n- torque limit (in percentage, for all motors of the actuator)\n- pid (for all motors of the actuator)\n- compliancy (for all motors of the actuator)\n\nLower properties that are read-only but acessible at actuator level:\n- temperatures (temperatures of all motors of the actuator)",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, uid: int, name: str, axis1: Axis, axis2: Axis, initial_state: Orbita2dState, grpc_channel: Channel, part: Part, joints_position_order: List[int])",
        "docstring": "Initialize the Orbita2d actuator with its joints, motors, and axes.\n\nArgs:\n    uid: The unique identifier for the actuator.\n    name: The name of the actuator.\n    axis1: The first axis of the actuator, typically representing roll, pitch, or yaw.\n    axis2: The second axis of the actuator, typically representing roll, pitch, or yaw.\n    initial_state: The initial state of the Orbita2d actuator, containing the states\n        of the joints, motors, and axes.\n    grpc_channel: The gRPC communication channel used for interfacing with the\n        Orbita2d actuator.\n    part: The robot part that this actuator belongs to.\n    joints_position_order: A list defining the order of the joint positions in the\n        containing part, used to map the actuator's joint positions correctly.",
        "source_code": " methods to Orbita2d.\n\"\"\"\n\nfrom typing import Any, Dict, List\n\nfro",
        "return_type": null,
        "parameters": {
          "self": "Any",
          "uid": "int",
          "name": "str",
          "axis1": "Axis",
          "axis2": "Axis",
          "initial_state": "Orbita2dState",
          "grpc_channel": "Channel",
          "part": "Part",
          "joints_position_order": "List[int]"
        }
      },
      {
        "name": "send_goal_positions",
        "signature": "(self, check_positions: bool) -> None",
        "docstring": "Send goal positions to the actuator's joints.\n\nIf goal positions have been specified for any joint of this actuator, sends them to the actuator.\n\nArgs :\n    check_positions: A boolean indicating whether to check the positions after sending the command.\n        Defaults to True.",
        "source_code": "ort Channel\nfrom reachy2_sdk",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "check_positions": "bool"
        }
      },
      {
        "name": "set_speed_limits",
        "signature": "(self, speed_limit: float | int) -> None",
        "docstring": "Set the speed limit as a percentage of the maximum speed for all motors of the actuator.\n\nArgs:\n    speed_limit: The desired speed limit as a percentage (0-100) of the maximum speed. Can be\n        specified as a float or int.",
        "source_code": "api.component_pb2 imp",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "speed_limit": "float | int"
        }
      },
      {
        "name": "set_torque_limits",
        "signature": "(self, torque_limit: float | int) -> None",
        "docstring": "Set the torque limit as a percentage of the maximum torque for all motors of the actuator.\n\nArgs:\n    torque_limit: The desired torque limit as a percentage (0-100) of the maximum torque. Can be\n        specified as a float or int.",
        "source_code": "rt ComponentId\nfrom r",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "torque_limit": "float | int"
        }
      }
    ],
    "source": "reachy2_sdk.orbita.orbita2d.Orbita2d"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.orbita.orbita3d",
    "docstring": "Reachy Orbita3d module.\n\nHandles all specific methods to Orbita3d.",
    "source": "orbita.orbita3d"
  },
  {
    "type": "class",
    "name": "Orbita3d",
    "module": "reachy2_sdk.orbita.orbita3d",
    "docstring": "The Orbita3d class represents any Orbita3d actuator and its joints, motors and axis.\n\nThe Orbita3d class is used to store the up-to-date state of the actuator, especially:\n- its compliancy\n- its joints state\n- its motors state\n- its axis state\n\nYou can access properties of the motors from the actuators with function that act on all the actuator's motors:\n- speed limit (in percentage, for all motors of the actuator)\n- torque limit (in percentage, for all motors of the actuator)\n- pid (for all motors of the actuator)\n- compliancy (for all motors of the actuator)\n\nLower properties that are read-only but acessible at actuator level:\n- temperatures (temperatures of all motors of the actuator)",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, uid: int, name: str, initial_state: Orbita3dState, grpc_channel: Channel, part: Part, joints_position_order: List[int])",
        "docstring": "Initialize the Orbita3d actuator with its joints, motors, and axes.\n\nArgs:\n    uid: The unique identifier for the actuator.\n    name: The name of the actuator.\n    initial_state: The initial state of the Orbita3d actuator, containing the states\n        of the joints, motors, and axes.\n    grpc_channel: The gRPC communication channel used for interfacing with the\n        Orbita3d actuator.\n    part: The robot part that this actuator belongs to.\n    joints_position_order: A list defining the order of the joint positions in the\n        containing part, used to map the actuator's joint positions correctly.",
        "source_code": "c methods to Orbita3d.\n\"\"\"\n\nfrom typing import Dic",
        "return_type": null,
        "parameters": {
          "self": "Any",
          "uid": "int",
          "name": "str",
          "initial_state": "Orbita3dState",
          "grpc_channel": "Channel",
          "part": "Part",
          "joints_position_order": "List[int]"
        }
      },
      {
        "name": "roll",
        "signature": "(self) -> OrbitaJoint",
        "docstring": "Get the roll joint of the actuator.",
        "source_code": "por",
        "return_type": "OrbitaJoint",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "pitch",
        "signature": "(self) -> OrbitaJoint",
        "docstring": "Get the pitch joint of the actuator.",
        "source_code": "Flo",
        "return_type": "OrbitaJoint",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "yaw",
        "signature": "(self) -> OrbitaJoint",
        "docstring": "Get the yaw joint of the actuator.",
        "source_code": "Val",
        "return_type": "OrbitaJoint",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "send_goal_positions",
        "signature": "(self, check_positions: bool) -> None",
        "docstring": "Send goal positions to the actuator's joints.\n\nIf goal positions have been specified for any joint of this actuator, sends them to the actuator.\n\nArgs:\n    check_positions: A boolean indicating whether to check the positions after sending the command.",
        "source_code": "e\nfrom grpc import Channel\n",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "check_positions": "bool"
        }
      },
      {
        "name": "set_speed_limits",
        "signature": "(self, speed_limit: float | int) -> None",
        "docstring": "Set the speed limit as a percentage of the maximum speed for all motors of the actuator.\n\nArgs:\n    speed_limit: The desired speed limit as a percentage (0-100) of the maximum speed. Can be\n        specified as a float or int.",
        "source_code": "rom reachy2_sdk_api.co",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "speed_limit": "float | int"
        }
      },
      {
        "name": "set_torque_limits",
        "signature": "(self, torque_limit: float | int) -> None",
        "docstring": "Set the torque limit as a percentage of the maximum torque for all motors of the actuator.\n\nArgs:\n    torque_limit: The desired torque limit as a percentage (0-100) of the maximum torque. Can be\n        specified as a float or int.",
        "source_code": "ponent_pb2 import Comp",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "torque_limit": "float | int"
        }
      }
    ],
    "source": "reachy2_sdk.orbita.orbita3d.Orbita3d"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.orbita.utils",
    "docstring": "This module defines the utils class functions for Orbita.",
    "source": "orbita.utils"
  },
  {
    "type": "function",
    "name": "to_position",
    "module": "reachy2_sdk.orbita.utils",
    "signature": "(internal_pos: float) -> float",
    "docstring": "Convert an internal angular value in radians to a value in degrees.\n\nArgs:\n    internal_pos: The internal angular value in radians.\n\nReturns:\n    The corresponding angular value in degrees.",
    "source_code": "odule defi",
    "return_type": "float",
    "parameters": {
      "internal_pos": "float"
    },
    "source": "reachy2_sdk.orbita.utils.to_position"
  },
  {
    "type": "function",
    "name": "to_internal_position",
    "module": "reachy2_sdk.orbita.utils",
    "signature": "(pos: float) -> Any",
    "docstring": "Convert an angular value in degrees to a value in radians.\n\nThe server expects values in radians, so conversion is necessary.\n\nArgs:\n    pos: The angular value in degrees.\n\nReturns:\n    The corresponding value in radians.\n\nRaises:\n    TypeError: If the provided value is not of type int or float.",
    "source_code": "s the utils class ",
    "return_type": "Any",
    "parameters": {
      "pos": "float"
    },
    "source": "reachy2_sdk.orbita.utils.to_internal_position"
  },
  {
    "type": "function",
    "name": "unwrapped_pid_value",
    "module": "reachy2_sdk.orbita.utils",
    "signature": "(value: Any) -> Any",
    "docstring": "Unwrap the internal PID value from a gRPC protobuf object to a Python value.\n\nArgs:\n    value: The gRPC protobuf object containing the PID values.\n\nReturns:\n    A tuple representing the unwrapped PID gains (p, i, d).",
    "source_code": "nctions fo",
    "return_type": "Any",
    "parameters": {
      "value": "Any"
    },
    "source": "reachy2_sdk.orbita.utils.unwrapped_pid_value"
  },
  {
    "type": "function",
    "name": "wrapped_proto_value",
    "module": "reachy2_sdk.orbita.utils",
    "signature": "(value: bool | float | int) -> Any",
    "docstring": "Wrap a simple Python value to the corresponding gRPC protobuf type.\n\nArgs:\n    value: The value to be wrapped, which can be a bool, float, or int.\n\nReturns:\n    The corresponding gRPC protobuf object (BoolValue, FloatValue, or UInt32Value).\n\nRaises:\n    TypeError: If the provided value is not a supported type.",
    "source_code": "Orbita.\"\"\"\n\nfrom ty",
    "return_type": "Any",
    "parameters": {
      "value": "bool | float | int"
    },
    "source": "reachy2_sdk.orbita.utils.wrapped_proto_value"
  },
  {
    "type": "function",
    "name": "wrapped_pid_value",
    "module": "reachy2_sdk.orbita.utils",
    "signature": "(value: Any) -> Any",
    "docstring": "Wrap a simple Python value to the corresponding gRPC protobuf type.\n\nArgs:\n    value: The value to be wrapped, which can be a bool, float, or int.\n\nReturns:\n    The corresponding gRPC protobuf object (BoolValue, FloatValue, or UInt32Value).\n\nRaises:\n    TypeError: If the provided value is not a supported type.",
    "source_code": "ng import Any\n\nim",
    "return_type": "Any",
    "parameters": {
      "value": "Any"
    },
    "source": "reachy2_sdk.orbita.utils.wrapped_pid_value"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.orbita.orbita_motor",
    "docstring": "Reachy OrbitaMotor module.\n\nHandles all specific methods to OrbitaMotor.",
    "source": "orbita.orbita_motor"
  },
  {
    "type": "class",
    "name": "OrbitaMotor",
    "module": "reachy2_sdk.orbita.orbita_motor",
    "docstring": "The OrbitaMotor class represents any Orbita3d or Orbita2d motor.\n\nThe OrbitaMotor class is used to store the up-to-date state of the motor, especially:\n- its temperature (RO)\n- its compliancy (RO)\n- its speed limit (RW)\n- its torque limit (RW)\n- its pid (RW)",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, initial_state: Dict[str, Any], actuator: Any) -> None",
        "docstring": "Initialize the motor with its initial state.\n\nArgs:\n    initial_state: A dictionary containing the initial state values for the motor. The keys should include\n        \"temperature\", \"speed_limit\", \"torque_limit\", \"compliant\", and \"pid\", with corresponding\n        FloatValue objects as values.\n    actuator: The actuator to which the motor belongs.",
        "source_code": "ule.\n\nHandl",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "initial_state": "Dict[str, Any]",
          "actuator": "Any"
        }
      },
      {
        "name": "speed_limit",
        "signature": "(self) -> float",
        "docstring": "Get the speed limit of the motor, as a percentage of the max allowed speed, rounded to three decimal places.",
        "source_code": " al",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "temperature",
        "signature": "(self) -> float",
        "docstring": "Get the current temperature of the motor in Celsius degrees.",
        "source_code": "spe",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "torque_limit",
        "signature": "(self) -> float",
        "docstring": "Get the torque limit of the axis, as a percentage of the max allowed speed, rounded to three decimal places.",
        "source_code": "fic",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "compliant",
        "signature": "(self) -> float",
        "docstring": "Get the compliance status of the motor.",
        "source_code": "eth",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "pid",
        "signature": "(self) -> PIDGains",
        "docstring": "Get the PID gains of the motor.",
        "source_code": "s t",
        "return_type": "PIDGains",
        "parameters": {
          "self": "Any"
        }
      }
    ],
    "source": "reachy2_sdk.orbita.orbita_motor.OrbitaMotor"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.sensors.__init__",
    "docstring": "Sensors module.\n\nThis module provides Reachy's sensors: Lidar.",
    "source": "sensors.__init__"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.sensors.lidar",
    "docstring": "Reachy Lidar module.\n\nHandles all specific methods to the Lidar sensor.",
    "source": "sensors.lidar"
  },
  {
    "type": "class",
    "name": "Lidar",
    "module": "reachy2_sdk.sensors.lidar",
    "docstring": "LIDAR class for mobile base SDK.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, initial_state: LidarSafety, grpc_channel: grpc.Channel, part: Part) -> None",
        "docstring": "Initialize the LIDAR class.",
        "source_code": "andles all ",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "initial_state": "LidarSafety",
          "grpc_channel": "grpc.Channel",
          "part": "Part"
        }
      },
      {
        "name": "get_map",
        "signature": "(self) -> Optional[npt.NDArray[np.uint8]]",
        "docstring": "Retrieve the current map of the environment using lidar data.\n\nReturns:\n    The current map of the environment as an image (NumPy array) if the lidar map is successfully\n    retrieved. Returns `None` if no lidar map is retrieved.",
        "source_code": "fic methods to",
        "return_type": "Optional[npt.NDArray[np.uint8]]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "safety_slowdown_distance",
        "signature": "(self) -> float",
        "docstring": "Get the safety distance from obstacles in meters for the mobile base.\n\nThe mobile base's speed is slowed down if the direction of speed matches the direction of\nat least one LIDAR point within the safety distance range.",
        "source_code": "he Lida",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "safety_slowdown_distance",
        "signature": "(self, value: float) -> None",
        "docstring": "Set the safety distance for a Lidar sensor.\n\nArgs:\n    value: The safety distance to set for the LidarSafety object. This value specifies\n        the distance at which a safety slowdown should be initiated.",
        "source_code": "sensor.\n\"\"\"\n\ni",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "value": "float"
        }
      },
      {
        "name": "safety_critical_distance",
        "signature": "(self) -> float",
        "docstring": "Get the critical distance in meters of the mobile base from obstacles.\n\nThe mobile base's speed is reduced to zero if the direction of speed matches the direction\nof at least one LIDAR point within the critical distance range. If at least one point is\nwithin the critical distance, even movements that move away from the obstacles are slowed\ndown to the \"safety_zone\" speed.",
        "source_code": "ort loggi",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "safety_critical_distance",
        "signature": "(self, value: float) -> None",
        "docstring": "Set the critical distance for a Lidar safety feature.\n\nArgs:\n    value: The critical distance in meters for safety. This value specifies the distance\n        at which the mobile base should stop if moving in the direction of an obstacle.\n        If at least one point is within the critical distance, even movements that move\n        away from the obstacles are slowed down to the \"safety_zone\" speed.",
        "source_code": "\nfrom typing imp",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "value": "float"
        }
      },
      {
        "name": "safety_enabled",
        "signature": "(self) -> bool",
        "docstring": "Get the current status of the safety feature.\n\nReturns:\n    A boolean indicating whether the safety feature is enabled. If `True`, the safety feature is enabled.",
        "source_code": "t Optio",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "safety_enabled",
        "signature": "(self, value: bool) -> None",
        "docstring": "Set the safety status for the Lidar device.\n\nArgs:\n    value: A boolean indicating whether the safety features are enabled or disabled. If `True`, the safety feature\n        is enabled.",
        "source_code": "l\n\nimport cv2\n",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "value": "bool"
        }
      },
      {
        "name": "obstacle_detection_status",
        "signature": "(self) -> LidarObstacleDetectionStatus",
        "docstring": "Get the status of the lidar obstacle detection.\n\nReturns:\n    The status of the lidar obstacle detection, which can be one of the following values:\n    NO_OBJECT_DETECTED, OBJECT_DETECTED_SLOWDOWN, OBJECT_DETECTED_STOP, or DETECTION_ERROR.",
        "source_code": "port grp",
        "return_type": "LidarObstacleDetectionStatus",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "reset_safety_default_values",
        "signature": "(self) -> None",
        "docstring": "Reset default distance values for safety detection.\n\nThe reset values include:\n- safety_critical_distance\n- safety_slowdown_distance.",
        "source_code": "\nimport ",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      }
    ],
    "source": "reachy2_sdk.sensors.lidar.Lidar"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.config.reachy_info",
    "docstring": "ReachyInfo module.\n\nThis module provides main informations about the robot.",
    "source": "config.reachy_info"
  },
  {
    "type": "class",
    "name": "ReachyInfo",
    "module": "reachy2_sdk.config.reachy_info",
    "docstring": "The ReachyInfo class saves information of the global robot.\n\nThe ReachyInfo class gives access to informations that won't be modified during the session:\n    the robot's hardware version\n    the robot's core software version\n    the robot's configuration\n    the robot's serial_number\nBut also to the battery voltage.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, reachy: Reachy) -> None",
        "docstring": "Initialize the ReachyInfo instance with robot details.\n\nArgs:\n    reachy: The Reachy robot object, which provides the robot's info and configuration details.",
        "source_code": "This module provid",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "reachy": "Reachy"
        }
      },
      {
        "name": "battery_voltage",
        "signature": "(self) -> float",
        "docstring": "Get the battery voltage of the mobile base.\n\nIf the mobile base is present, returns its battery voltage. Otherwise, returns a default full\nbattery value.",
        "source_code": "ing import ",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "robot_serial_number",
        "signature": "(self) -> str",
        "docstring": "Returns the robot's serial number.",
        "source_code": "y, ",
        "return_type": "str",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "hardware_version",
        "signature": "(self) -> str",
        "docstring": "Returns the robot's hardware version.",
        "source_code": "ct,",
        "return_type": "str",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "core_software_version",
        "signature": "(self) -> str",
        "docstring": "Returns the robot's core software version.",
        "source_code": "ist",
        "return_type": "str",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "mode",
        "signature": "(self) -> str",
        "docstring": "Returns the robot's core mode.\n\nCan be either \"FAKE\", \"REAL\" or \"GAZEBO\".",
        "source_code": "Option",
        "return_type": "str",
        "parameters": {
          "self": "Any"
        }
      }
    ],
    "source": "reachy2_sdk.config.reachy_info.ReachyInfo"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.config.__init__",
    "docstring": "Config module.\n\nThis module manages the configuration of the connected robot.",
    "source": "config.__init__"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.utils.__init__",
    "docstring": "Utils module.\n\nThis module contains various useful methods and classes.",
    "source": "utils.__init__"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.utils.utils",
    "docstring": "Reachy utils module.\n\nThis module contains various useful functions especially:\n- angle conversion from/to degree/radian\n- enum conversion to string\n- matrix decomposition/recomposition\n- pose matrix creation\n- various grpc messages conversion",
    "source": "utils.utils"
  },
  {
    "type": "function",
    "name": "convert_to_radians",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(angles_list: List[float]) -> Any",
    "docstring": "Convert a list of angles from degrees to radians.\n\nArgs:\n    angles_list: A list of angles in degrees to convert to radians.\n\nReturns:\n    A list of angles converted to radians.",
    "source_code": "his module co",
    "return_type": "Any",
    "parameters": {
      "angles_list": "List[float]"
    },
    "source": "reachy2_sdk.utils.utils.convert_to_radians"
  },
  {
    "type": "function",
    "name": "convert_to_degrees",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(angles_list: List[float]) -> Any",
    "docstring": "Convert a list of angles from radians to degrees.\n\nArgs:\n    angles_list: A list of angles in radians to convert to degrees.\n\nReturns:\n    A list of angles converted to degrees.",
    "source_code": "ains various ",
    "return_type": "Any",
    "parameters": {
      "angles_list": "List[float]"
    },
    "source": "reachy2_sdk.utils.utils.convert_to_degrees"
  },
  {
    "type": "function",
    "name": "list_to_arm_position",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(positions: List[float], degrees: bool) -> ArmPosition",
    "docstring": "Convert a list of joint positions to an ArmPosition message, considering whether the positions are in degrees or radians.\n\nArgs:\n    positions: A list of float values representing joint positions. The list should contain 7 values\n        in the following order: [shoulder_pitch, shoulder_roll, elbow_yaw, elbow_pitch, wrist_roll, wrist_pitch,wrist_yaw].\n    degrees: A flag indicating whether the input joint positions are in degrees. If set to `True`,\n        the input positions are in degrees. Defaults to `True`.\n\nReturns:\n    An ArmPosition message containing the shoulder position, elbow position, and wrist position\n    based on the input list of joint positions.",
    "source_code": "eful functions especially:\n- angle",
    "return_type": "ArmPosition",
    "parameters": {
      "positions": "List[float]",
      "degrees": "bool"
    },
    "source": "reachy2_sdk.utils.utils.list_to_arm_position"
  },
  {
    "type": "function",
    "name": "arm_position_to_list",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(arm_pos: ArmPosition, degrees: bool) -> List[float]",
    "docstring": "Convert an ArmPosition message to a list of joint positions, with an option to return the result in degrees.\n\nArgs:\n    arm_pos: An ArmPosition message containing shoulder, elbow, and wrist positions.\n    degrees: Specifies whether the joint positions should be returned in degrees. If set to `True`,\n        the positions are converted to degrees. Defaults to `True`.\n\nReturns:\n    A list of joint positions based on the ArmPosition, returned in the following order:\n    [shoulder_pitch, shoulder_roll, elbow_yaw, elbow_pitch, wrist_roll, wrist_pitch, wrist_yaw].",
    "source_code": "onversion from/to degree/",
    "return_type": "List[float]",
    "parameters": {
      "arm_pos": "ArmPosition",
      "degrees": "bool"
    },
    "source": "reachy2_sdk.utils.utils.arm_position_to_list"
  },
  {
    "type": "function",
    "name": "ext_euler_angles_to_list",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(euler_angles: ExtEulerAngles, degrees: bool) -> List[float]",
    "docstring": "Convert an ExtEulerAngles 3D rotation message to a list of joint positions.\n\nArgs:\n    euler_angles: An ExtEulerAngles object representing a 3D rotation message.\n    degrees: Specifies whether the output should be in degrees. If set to `True`, the function\n        converts the angles to degrees before returning the list. Defaults to `True`.\n\nReturns:\n    A list of joint positions representing the Euler angles in the order [roll, pitch, yaw].",
    "source_code": "dian\n- enum conve",
    "return_type": "List[float]",
    "parameters": {
      "euler_angles": "ExtEulerAngles",
      "degrees": "bool"
    },
    "source": "reachy2_sdk.utils.utils.ext_euler_angles_to_list"
  },
  {
    "type": "function",
    "name": "get_grpc_interpolation_mode",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(interpolation_mode: str) -> GoToInterpolation",
    "docstring": "Convert a given interpolation mode string to a corresponding GoToInterpolation object.\n\nArgs:\n    interpolation_mode: A string representing the type of interpolation to be used. It can be either\n        \"minimum_jerk\" or \"linear\".\n\nReturns:\n    An instance of the GoToInterpolation class with the interpolation type set based on the input\n    interpolation_mode string.\n\nRaises:\n    ValueError: If the interpolation_mode is not \"minimum_jerk\" or \"linear\".",
    "source_code": "ion to string\n- matrix",
    "return_type": "GoToInterpolation",
    "parameters": {
      "interpolation_mode": "str"
    },
    "source": "reachy2_sdk.utils.utils.get_grpc_interpolation_mode"
  },
  {
    "type": "function",
    "name": "get_interpolation_mode",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(interpolation_mode: InterpolationMode) -> str",
    "docstring": "Convert an interpolation mode enum to a string representation.\n\nArgs:\n    interpolation_mode: The interpolation mode given as InterpolationMode. The supported interpolation\n        modes are MINIMUM_JERK and LINEAR.\n\nReturns:\n    A string representing the interpolation mode based on the input interpolation_mode. Returns\n    \"minimum_jerk\" if the mode is InterpolationMode.MINIMUM_JERK, and \"linear\" if it is\n    InterpolationMode.LINEAR.\n\nRaises:\n    ValueError: If the interpolation_mode is not InterpolationMode.MINIMUM_JERK or InterpolationMode.LINEAR.",
    "source_code": "ecomposition/recomposit",
    "return_type": "str",
    "parameters": {
      "interpolation_mode": "InterpolationMode"
    },
    "source": "reachy2_sdk.utils.utils.get_interpolation_mode"
  },
  {
    "type": "function",
    "name": "decompose_matrix",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(matrix: npt.NDArray[np.float64]) -> Tuple[Quaternion, npt.NDArray[np.float64]]",
    "docstring": "Decompose a homogeneous 4x4 matrix into rotation (represented as a quaternion) and translation components.\n\nArgs:\n    matrix: A homogeneous 4x4 matrix represented as a NumPy array of type np.float64.\n\nReturns:\n    A tuple containing a Quaternion representing the rotation component and a NumPy array\n    representing the translation component of the input matrix.",
    "source_code": "n\n- pose matrix c",
    "return_type": "Tuple[Quaternion, npt.NDArray[np.float64]]",
    "parameters": {
      "matrix": "npt.NDArray[np.float64]"
    },
    "source": "reachy2_sdk.utils.utils.decompose_matrix"
  },
  {
    "type": "function",
    "name": "recompose_matrix",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(rotation: npt.NDArray[np.float64], translation: npt.NDArray[np.float64]) -> npt.NDArray[np.float64]",
    "docstring": "Recompose a homogeneous 4x4 matrix from rotation (quaternion) and translation components.\n\nArgs:\n    rotation: A 3x3 rotation matrix represented as a NumPy array of type np.float64.\n    translation: A vector representing the displacement in space, containing the x, y, and z\n        components of the translation vector.\n\nReturns:\n    A homogeneous 4x4 matrix composed from the provided rotation and translation components.",
    "source_code": "ation\n- various",
    "return_type": "npt.NDArray[np.float64]",
    "parameters": {
      "rotation": "npt.NDArray[np.float64]",
      "translation": "npt.NDArray[np.float64]"
    },
    "source": "reachy2_sdk.utils.utils.recompose_matrix"
  },
  {
    "type": "function",
    "name": "matrix_from_euler_angles",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(roll: float, pitch: float, yaw: float, degrees: bool) -> npt.NDArray[np.float64]",
    "docstring": "Create a 4x4 homogeneous rotation matrix from roll, pitch, and yaw angles, with an option to input angles in degrees.\n\nArgs:\n    roll: The rotation angle around the x-axis in the Euler angles representation.\n    pitch: The rotation angle around the y-axis in the Euler angles representation.\n    yaw: The rotation angle around the z-axis in the Euler angles representation.\n    degrees: Specifies whether the input angles (roll, pitch, yaw) are in degrees. If set to `True`,\n        the input angles are expected to be in degrees. Defaults to `True`.\n\nReturns:\n    A 4x4 homogeneous rotation matrix created from the input roll, pitch, and yaw angles.",
    "source_code": "rpc messages conversion\n\"\"\"\n\nfrom",
    "return_type": "npt.NDArray[np.float64]",
    "parameters": {
      "roll": "float",
      "pitch": "float",
      "yaw": "float",
      "degrees": "bool"
    },
    "source": "reachy2_sdk.utils.utils.matrix_from_euler_angles"
  },
  {
    "type": "function",
    "name": "get_pose_matrix",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(position: List[float], rotation: List[float], degrees: bool) -> npt.NDArray[np.float64]",
    "docstring": "Create a 4x4 pose matrix from a position vector and \"roll, pitch, yaw\" angles (rotation).\n\nArgs:\n    position: A list of size 3 representing the requested position of the end effector in the Reachy coordinate system.\n    rotation: A list of size 3 representing the requested orientation of the end effector in the Reachy coordinate system.\n        The rotation is given as intrinsic angles, executed in roll, pitch, yaw order.\n    degrees: Specifies whether the input angles are in degrees. If set to `True`, the angles are interpreted as degrees.\n        If set to `False`, they are interpreted as radians. Defaults to `True`.\n\nReturns:\n    The constructed 4x4 pose matrix.\n\nRaises:\n    TypeError: If `position` is not a list of floats or integers.\n    TypeError: If `rotation` is not a list of floats or integers.\n    ValueError: If the length of `position` is not 3.\n    ValueError: If the length of `rotation` is not 3.",
    "source_code": "ollections import namedtuple\nfrom t",
    "return_type": "npt.NDArray[np.float64]",
    "parameters": {
      "position": "List[float]",
      "rotation": "List[float]",
      "degrees": "bool"
    },
    "source": "reachy2_sdk.utils.utils.get_pose_matrix"
  },
  {
    "type": "function",
    "name": "quaternion_from_euler_angles",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(roll: float, pitch: float, yaw: float, degrees: bool) -> Quaternion",
    "docstring": "Convert Euler angles (intrinsic XYZ order) to a quaternion using the pyquaternion library.\n\nArgs:\n    roll (float): Rotation angle around the X-axis (roll), in degrees by default.\n    pitch (float): Rotation angle around the Y-axis (pitch), in degrees by default.\n    yaw (float): Rotation angle around the Z-axis (yaw), in degrees by default.\n    degrees (bool): If True, the input angles are interpreted as degrees. If False, they are\n        interpreted as radians. Defaults to True.\n\nReturns:\n    Quaternion: The quaternion representing the combined rotation in 3D space.",
    "source_code": "ing import Any, List, Opt",
    "return_type": "Quaternion",
    "parameters": {
      "roll": "float",
      "pitch": "float",
      "yaw": "float",
      "degrees": "bool"
    },
    "source": "reachy2_sdk.utils.utils.quaternion_from_euler_angles"
  },
  {
    "type": "function",
    "name": "rotate_in_self",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(frame: npt.NDArray[np.float64], rotation: List[float], degrees: bool) -> npt.NDArray[np.float64]",
    "docstring": "Return a new homogeneous 4x4 pose matrix that is the input matrix rotated in itself.\n\nArgs:\n    frame: The input frame, given as a 4x4 homogeneous matrix.\n    rotation: A list of size 3 representing the rotation to be applied. The rotation is given as intrinsic angles,\n        executed in roll, pitch, yaw order.\n    degrees: Specifies whether the input angles are in degrees. If set to `True`, the angles are interpreted as degrees.\n        If set to `False`, they are interpreted as radians. Defaults to `True`.\n\nReturns:\n    A new 4x4 homogeneous matrix after applying the specified rotation.",
    "source_code": "nal, Tuple\n\nimport numpy ",
    "return_type": "npt.NDArray[np.float64]",
    "parameters": {
      "frame": "npt.NDArray[np.float64]",
      "rotation": "List[float]",
      "degrees": "bool"
    },
    "source": "reachy2_sdk.utils.utils.rotate_in_self"
  },
  {
    "type": "function",
    "name": "translate_in_self",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(frame: npt.NDArray[np.float64], translation: List[float]) -> npt.NDArray[np.float64]",
    "docstring": "Return a new homogeneous 4x4 pose matrix that is the input frame translated along its own axes.\n\nArgs:\n    frame: The input frame, given as a 4x4 homogeneous matrix.\n    translation: A list of size 3 representing the translation to be applied, given as [x, y, z].\n\nReturns:\n    A new homogeneous 4x4 pose matrix after translating the input frame along its own axes.",
    "source_code": " np\nimport numpy.typin",
    "return_type": "npt.NDArray[np.float64]",
    "parameters": {
      "frame": "npt.NDArray[np.float64]",
      "translation": "List[float]"
    },
    "source": "reachy2_sdk.utils.utils.translate_in_self"
  },
  {
    "type": "function",
    "name": "invert_affine_transformation_matrix",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(matrix: npt.NDArray[np.float64]) -> npt.NDArray[np.float64]",
    "docstring": "Invert a 4x4 homogeneous transformation matrix.\n\nThe function computes the inverse by transposing the rotation component and adjusting the translation component.\n\nArgs:\n    matrix: A 4x4 NumPy array representing a homogeneous transformation matrix.\n\nReturns:\n    A new 4x4 homogeneous matrix that is the inverse of the input matrix.\n\nRaises:\n    ValueError: If the input matrix is not 4x4.",
    "source_code": "as npt\nfrom google.pr",
    "return_type": "npt.NDArray[np.float64]",
    "parameters": {
      "matrix": "npt.NDArray[np.float64]"
    },
    "source": "reachy2_sdk.utils.utils.invert_affine_transformation_matrix"
  },
  {
    "type": "function",
    "name": "get_normal_vector",
    "module": "reachy2_sdk.utils.utils",
    "signature": "(vector: npt.NDArray[np.float64], arc_direction: str) -> Optional[npt.NDArray[np.float64]]",
    "docstring": "Calculate a normal vector to a given vector based on a specified direction.\n\nArgs:\n    vector: A vector [x, y, z] in 3D space.\n    arc_direction: The desired direction for the normal vector. It can be one of the following options:\n        'above', 'below', 'front', 'back', 'right', or 'left'.\n\nReturns:\n    The normal vector [x, y, z] to the given vector in the specified direction. Returns `None` if the\n    normal vector cannot be computed or if the vector is in the requested arc_direction.\n\nRaises:\n    ValueError: If the arc_direction is not one of 'above', 'below', 'front', 'back', 'right', or 'left'.",
    "source_code": "obuf.wrappers_pb2 import FloatValue\nfrom pyquaternio",
    "return_type": "Optional[npt.NDArray[np.float64]]",
    "parameters": {
      "vector": "npt.NDArray[np.float64]",
      "arc_direction": "str"
    },
    "source": "reachy2_sdk.utils.utils.get_normal_vector"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.utils.custom_dict",
    "docstring": "Custom dict module.\n\nDefines a custom dict class to modify repr of dict.",
    "source": "utils.custom_dict"
  },
  {
    "type": "class",
    "name": "CustomDict",
    "module": "reachy2_sdk.utils.custom_dict",
    "docstring": "CustomDict is an implementation of dict with a custom __repr__ method, to enhance readability.",
    "methods": [],
    "source": "reachy2_sdk.utils.custom_dict.CustomDict"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.parts.goto_based_part",
    "docstring": "Reachy IGoToBasedPart interface.\n\nHandles common interface for parts performing movement using goto mechanism.",
    "source": "parts.goto_based_part"
  },
  {
    "type": "class",
    "name": "IGoToBasedPart",
    "module": "reachy2_sdk.parts.goto_based_part",
    "docstring": "Interface for parts of Reachy that use goto functions.\n\nThe `IGoToBasedPart` class defines a common interface for handling goto-based movements. It is\ndesigned to be implemented by parts of the robot that perform movements via the goto mechanism,\nsuch as the Arm, Head, or potentially the MobileBase in the future.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, part: Part, goto_stub: GoToServiceStub) -> None",
        "docstring": "Initialize the IGoToBasedPart interface.\n\nSets up the common attributes needed for handling goto-based movements. This includes\nassociating the part with the interface and setting up the gRPC stub for performing\ngoto commands.\n\nArgs:\n    part: The robot part that uses this interface, such as an Arm or Head.\n    goto_stub: The gRPC stub used to send goto commands to the robot part.",
        "source_code": "face.\n\nHandles com",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "part": "Part",
          "goto_stub": "GoToServiceStub"
        }
      },
      {
        "name": "get_goto_playing",
        "signature": "(self) -> GoToId",
        "docstring": "Return the GoToId of the currently playing goto movement on a specific part.",
        "source_code": "on i",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_goto_queue",
        "signature": "(self) -> List[GoToId]",
        "docstring": "Return a list of all GoToIds waiting to be played on a specific part.",
        "source_code": "terf",
        "return_type": "List[GoToId]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "cancel_all_goto",
        "signature": "(self) -> GoToAck",
        "docstring": "Request the cancellation of all playing and waiting goto commands for a specific part.\n\nReturns:\n    A GoToAck acknowledging the cancellation of all goto commands.",
        "source_code": "ce for p",
        "return_type": "GoToAck",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "goto_posture",
        "signature": "(self, common_posture: str, duration: float, wait: bool, wait_for_goto_end: bool, interpolation_mode: str) -> GoToId",
        "docstring": "Send all joints to standard positions with optional parameters for duration, waiting, and interpolation mode.",
        "source_code": "rt ABC, ab",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "common_posture": "str",
          "duration": "float",
          "wait": "bool",
          "wait_for_goto_end": "bool",
          "interpolation_mode": "str"
        }
      }
    ],
    "source": "reachy2_sdk.parts.goto_based_part.IGoToBasedPart"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.parts.joints_based_part",
    "docstring": "Reachy JointsBasedPart module.\n\nHandles all specific methods to parts composed of controllable joints.",
    "source": "parts.joints_based_part"
  },
  {
    "type": "class",
    "name": "JointsBasedPart",
    "module": "reachy2_sdk.parts.joints_based_part",
    "docstring": "Base class for parts of the robot composed of controllable joints.\n\nThe `JointsBasedPart` class serves as a base for parts of the robot that consist of multiple joints,\nsuch as arms and heads. This class provides common functionality for controlling joints, setting speed\nand torque limits, and managing joint positions.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, proto_msg: Arm_proto | Head_proto, grpc_channel: grpc.Channel, stub: ArmServiceStub | HeadServiceStub) -> None",
        "docstring": "Initialize the JointsBasedPart with its common attributes.\n\nSets up the gRPC communication channel and service stub for controlling the joint-based\npart of the robot, such as an arm or head.\n\nArgs:\n    proto_msg: A protocol message representing the part's configuration. It can be an\n        Arm_proto or Head_proto object.\n    grpc_channel: The gRPC channel used to communicate with the corresponding service.\n    stub: The service stub for the gRPC communication, which can be an ArmServiceStub or\n        HeadServiceStub, depending on the part type.",
        "source_code": "dule.\n\nHandles all ",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "proto_msg": "Arm_proto | Head_proto",
          "grpc_channel": "grpc.Channel",
          "stub": "ArmServiceStub | HeadServiceStub"
        }
      },
      {
        "name": "joints",
        "signature": "(self) -> CustomDict[str, OrbitaJoint]",
        "docstring": "Get all the arm's joints.\n\nReturns:\n    A dictionary of all the arm's joints, with joint names as keys and joint objects as values.",
        "source_code": "ecific meth",
        "return_type": "CustomDict[str, OrbitaJoint]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_current_positions",
        "signature": "(self) -> List[float]",
        "docstring": "Get the current positions of all joints.\n\nReturns:\n    A list of float values representing the present positions in degrees of the arm's joints.",
        "source_code": "s to pa",
        "return_type": "List[float]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "send_goal_positions",
        "signature": "(self, check_positions: bool) -> None",
        "docstring": "Send goal positions to the part's joints.\n\nIf goal positions have been specified for any joint of the part, sends them to the robot.\n\nArgs :\n    check_positions: A boolean indicating whether to check the positions after sending the command.\n        Defaults to True.",
        "source_code": "s composed",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "check_positions": "bool"
        }
      },
      {
        "name": "set_torque_limits",
        "signature": "(self, torque_limit: int) -> None",
        "docstring": "Set the torque limit as a percentage of the maximum torque for all motors of the part.\n\nArgs:\n    torque_limit: The desired torque limit as a percentage (0-100) of the maximum torque. Can be\n        specified as a float or int.",
        "source_code": "of controllable ",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "torque_limit": "int"
        }
      },
      {
        "name": "set_speed_limits",
        "signature": "(self, speed_limit: int) -> None",
        "docstring": "Set the speed limit as a percentage of the maximum speed for all motors of the part.\n\nArgs:\n    speed_limit: The desired speed limit as a percentage (0-100) of the maximum speed. Can be\n        specified as a float or int.",
        "source_code": "oints.\n\"\"\"\n\nfrom",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "speed_limit": "int"
        }
      }
    ],
    "source": "reachy2_sdk.parts.joints_based_part.JointsBasedPart"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.parts.mobile_base",
    "docstring": "Reachy MobileBase module.\n\nHandles all specific methods to a MobileBase.",
    "source": "parts.mobile_base"
  },
  {
    "type": "class",
    "name": "MobileBase",
    "module": "reachy2_sdk.parts.mobile_base",
    "docstring": "MobileBase class for controlling Reachy's mobile base.\n\nThis class provides methods to interact with and control the mobile base of a Reachy robot. It allows\nusers to access essential information such as battery voltage and odometry, as well as send commands\nto move the base to specified positions or velocities. The class supports different drive modes and\ncontrol modes, and provides methods for resetting the base's odometry.\n\nAttributes:\n    lidar: Lidar object for handling safety features.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, mb_msg: MobileBase_proto, initial_state: MobileBaseState, grpc_channel: grpc.Channel) -> None",
        "docstring": "Initialize the MobileBase with its gRPC communication and configuration.\n\nThis sets up the gRPC communication channel and service stubs for controlling the\nmobile base, initializes the drive and control modes.\nIt also sets up the LIDAR safety monitoring.\n\nArgs:\n    mb_msg: A MobileBase_proto message containing the configuration details for the mobile base.\n    initial_state: The initial state of the mobile base, as a MobileBaseState object.\n    grpc_channel: The gRPC channel used to communicate with the mobile base service.",
        "source_code": "methods to a MobileBase.\n\"\"\"\n\nimp",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "mb_msg": "MobileBase_proto",
          "initial_state": "MobileBaseState",
          "grpc_channel": "grpc.Channel"
        }
      },
      {
        "name": "battery_voltage",
        "signature": "(self) -> float",
        "docstring": "Return the battery voltage.\n\nThe battery should be recharged if the voltage reaches 24.5V or below. If the battery level is low,\na warning message is logged.\n\nReturns:\n    The current battery voltage as a float, rounded to one decimal place.",
        "source_code": "mport logging",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "odometry",
        "signature": "(self) -> Dict[str, float]",
        "docstring": "Return the odometry of the base.\n\nThe odometry includes the x and y positions in meters and theta in degrees, along with the\nvelocities in the x, y directions in meters per degrees and the angular velocity in degrees per second.\n\nReturns:\n    A dictionary containing the current odometry with keys 'x', 'y', 'theta', 'vx', 'vy', and 'vtheta',\n    each rounded to three decimal places.",
        "source_code": "mport time\nfrom conc",
        "return_type": "Dict[str, float]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "last_cmd_vel",
        "signature": "(self) -> Dict[str, float]",
        "docstring": "Return the last command velocity sent to the base.\n\nThe velocity includes the x and y components in meters per second and the theta component in degrees per second.\n\nReturns:\n    A dictionary containing the last command velocity with keys 'x', 'y', and 'theta',\n    each rounded to three decimal places.",
        "source_code": "rent.futures imp",
        "return_type": "Dict[str, float]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_on",
        "signature": "(self) -> bool",
        "docstring": "Check if the mobile base is currently stiff (not in free-wheel mode).\n\nReturns:\n    `True` if the mobile base is not compliant (stiff), `False` otherwise.",
        "source_code": "ueue\nfr",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_off",
        "signature": "(self) -> bool",
        "docstring": "Check if the mobile base is currently compliant (in free-wheel mode).\n\nReturns:\n    True if the mobile base is compliant (in free-wheel mode), `False` otherwise.",
        "source_code": "m typing ",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_current_odometry",
        "signature": "(self, degrees: bool) -> Dict[str, float]",
        "docstring": "Get the current odometry of the mobile base in its reference frame.\n\nArgs:\n    degrees (bool, optional): Whether to return the orientation (`theta` and `vtheta`) in degrees.\n                            Defaults to True.\n\nReturns:\n    Dict[str, float]: A dictionary containing the current odometry of the mobile base with:\n    - 'x': Position along the x-axis (in meters).\n    - 'y': Position along the y-axis (in meters).\n    - 'theta': Orientation (in degrees by default, radians if `degrees=False`).\n    - 'vx': Linear velocity along the x-axis (in meters per second).\n    - 'vy': Linear velocity along the y-axis (in meters per second).\n    - 'vtheta': Angular velocity (in degrees per second by default, radians if `degrees=False`).",
        "source_code": "mport Dict, Optional\n\n",
        "return_type": "Dict[str, float]",
        "parameters": {
          "self": "Any",
          "degrees": "bool"
        }
      },
      {
        "name": "goto",
        "signature": "(self, x: float, y: float, theta: float, timeout: Optional[float], tolerance: Dict[str, float]) -> None",
        "docstring": "Send the mobile base to a specified target position.\n\nThe (x, y) coordinates define the position in Cartesian space, and theta specifies the orientation in degrees.\nThe zero position is set when the mobile base is started or when the `reset_odometry` method is called. A timeout\ncan be provided to avoid the mobile base getting stuck. The tolerance values define the acceptable margins for\nreaching the target position.\n\nArgs:\n    x: The target x-coordinate in meters.\n    y: The target y-coordinate in meters.\n    theta: The target orientation in degrees.\n    timeout: Optional; the maximum time allowed to reach the target, in seconds.\n    tolerance: A dictionary specifying the tolerances for x, y, theta, and overall distance to\n        consider the target reached. Defaults to {\"delta_x\": 0.05, \"delta_y\": 0.05, \"delta_theta\": 5, \"distance\": 0.05}.\n\nRaises:\n    ValueError: If the target is not reached and the mobile base is stopped due to an obstacle.",
        "source_code": "mport grpc\nimport numpy as np\nfrom google.protobuf.wrap",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "x": "float",
          "y": "float",
          "theta": "float",
          "timeout": "Optional[float]",
          "tolerance": "Dict[str, float]"
        }
      },
      {
        "name": "translate_by",
        "signature": "(self, x: float, y: float, timeout: Optional[float]) -> None",
        "docstring": "Send a target position relative to the current position of the mobile base.\n\nThe (x, y) coordinates specify the desired translation in the mobile base's Cartesian space.\n\nArgs:\n    x: The desired translation along the x-axis in meters.\n    y: The desired translation along the y-axis in meters.\n    timeout: An optional timeout for reaching the target position, in seconds.",
        "source_code": "api.mobile_base_mo",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "x": "float",
          "y": "float",
          "timeout": "Optional[float]"
        }
      },
      {
        "name": "rotate_by",
        "signature": "(self, theta: float, timeout: Optional[float]) -> None",
        "docstring": "Send a target rotation relative to the current rotation of the mobile base.\n\nThe theta parameter defines the desired rotation in degrees.\n\nArgs:\n    theta: The desired rotation in degrees, relative to the current orientation.\n    timeout: An optional timeout for completing the rotation, in seconds.",
        "source_code": "ility_pb2 impo",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "theta": "float",
          "timeout": "Optional[float]"
        }
      },
      {
        "name": "reset_odometry",
        "signature": "(self) -> None",
        "docstring": "Reset the odometry.\n\nThis method resets the mobile base's odometry, so that the current position is now (x, y, theta) = (0, 0, 0).",
        "source_code": "t (\n   ",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "set_goal_speed",
        "signature": "(self, x: float | int, y: float | int, theta: float | int) -> None",
        "docstring": "Set the goal speed for the mobile base.\n\nThis method sets the target velocities for the mobile base's movement along the x and y axes, as well as\nits rotational speed. The actual movement is executed after calling `send_speed_command`.\n\nArgs:\n    x (float | int, optional): Linear velocity along the x-axis in meters per second. Defaults to 0.\n    y (float | int, optional): Linear velocity along the y-axis in meters per second. Defaults to 0.\n    theta (float | int, optional): Rotational velocity (around the z-axis) in degrees per second. Defaults to 0.\n\nRaises:\n    TypeError: If any of the velocity values (`x`, `y`, `theta`) are not of type `float` or `int`.\n\nNotes:\n    - Use `send_speed_command` after this method to execute the movement.\n    - The velocities will be used to command the mobile base for a short duration (0.2 seconds).",
        "source_code": "DirectionVector,\n    GoTo",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "x": "float | int",
          "y": "float | int",
          "theta": "float | int"
        }
      },
      {
        "name": "send_speed_command",
        "signature": "(self) -> None",
        "docstring": "Send the speed command to the mobile base, based on previously set goal speeds.\n\nThis method sends the velocity commands for the mobile base that were set with `set_goal_speed`.\nThe command will be executed for a duration of 200ms, which is predefined at the ROS level of the mobile base code.\n\nRaises:\n    ValueError: If the absolute value of `x_vel`, `y_vel`, or `rot_vel` exceeds the configured maximum values.\n    Warning: If the mobile base is off, no command is sent, and a warning is logged.\n\nNotes:\n    - This method is optimal for sending frequent speed instructions to the mobile base.\n    - The goal velocities must be set with `set_goal_speed` before calling this function.",
        "source_code": "ector,\n    TargetDirectionCommand,\n",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      }
    ],
    "source": "reachy2_sdk.parts.mobile_base.MobileBase"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.parts.__init__",
    "docstring": "Parts module.\n\nThis module provides Reachy's parts: Arm, Head, Hand and MobileBase.",
    "source": "parts.__init__"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.parts.arm",
    "docstring": "Reachy Arm module.\n\nHandles all specific methods to an Arm (left and/or right).",
    "source": "parts.arm"
  },
  {
    "type": "class",
    "name": "Arm",
    "module": "reachy2_sdk.parts.arm",
    "docstring": "Reachy Arm module.\n\nHandles specific functionalities for the arm (left and/or right), including:\n- Forward and inverse kinematics\n- Goto functions for movement\n- Turning the arm on and off\n- Cartesian interpolation for movements\n\nAttributes:\n    shoulder (Orbita2d): The shoulder actuator of the arm.\n    elbow (Orbita2d): The elbow actuator of the arm.\n    wrist (Orbita3d): The wrist actuator of the arm.\n    gripper (Optional[Hand]): The gripper of the arm, if initialized.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, arm_msg: Arm_proto, initial_state: ArmState, grpc_channel: grpc.Channel, goto_stub: GoToServiceStub) -> None",
        "docstring": "Initialize an Arm instance.\n\nThis constructor sets up the arm's gRPC communication and initializes its actuators\n(shoulder, elbow, and wrist). Optionally, a gripper can also be configured.\n\nArgs:\n    arm_msg: The protobuf message containing the arm's configuration details.\n    initial_state: The initial state of the arm's actuators.\n    grpc_channel: The gRPC channel used for communication with the arm's server.\n    goto_stub: The gRPC stub for controlling goto movements.",
        "source_code": "or right).\n\"\"\"\n\nimport time\n",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "arm_msg": "Arm_proto",
          "initial_state": "ArmState",
          "grpc_channel": "grpc.Channel",
          "goto_stub": "GoToServiceStub"
        }
      },
      {
        "name": "shoulder",
        "signature": "(self) -> Orbita2d",
        "docstring": "Get the shoulder actuator of the arm.",
        "source_code": "ove",
        "return_type": "Orbita2d",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "elbow",
        "signature": "(self) -> Orbita2d",
        "docstring": "Get the elbow actuator of the arm.",
        "source_code": "oad",
        "return_type": "Orbita2d",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "wrist",
        "signature": "(self) -> Orbita3d",
        "docstring": "Get the wrist actuator of the arm.",
        "source_code": "imp",
        "return_type": "Orbita3d",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "gripper",
        "signature": "(self) -> Optional[Hand]",
        "docstring": "Get the gripper of the arm, or None if not set.",
        "source_code": "t g",
        "return_type": "Optional[Hand]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "turn_on",
        "signature": "(self) -> None",
        "docstring": "Turn on all motors of the part, making all arm motors stiff.\n\nIf a gripper is present, it will also be turned on.",
        "source_code": "rt numpy",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "turn_off",
        "signature": "(self) -> None",
        "docstring": "Turn off all motors of the part, making all arm motors compliant.\n\nIf a gripper is present, it will also be turned off.",
        "source_code": "as np\nim",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "turn_off_smoothly",
        "signature": "(self) -> None",
        "docstring": "Gradually reduce the torque limit of all motors over 3 seconds before turning them off.\n\nThis function decreases the torque limit in steps until the motors are turned off.\nIt then restores the torque limit to its original value.",
        "source_code": "ort numpy.typing as np",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_on",
        "signature": "(self) -> bool",
        "docstring": "Check if all actuators of the arm are stiff.\n\nReturns:\n    `True` if all actuators of the arm are stiff, `False` otherwise.",
        "source_code": "buf.wrapp",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_off",
        "signature": "(self) -> bool",
        "docstring": "Check if all actuators of the arm are compliant.\n\nReturns:\n    `True` if all actuators of the arm are compliant, `False` otherwise.",
        "source_code": "rs_pb2 im",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_current_positions",
        "signature": "(self, degrees: bool) -> List[float]",
        "docstring": "Return the current joint positions of the arm, either in degrees or radians.\n\nArgs:\n    degrees: Specifies whether the joint positions should be returned in degrees.\n        If set to `True`, the positions are returned in degrees; otherwise, they are returned in radians.\n        Defaults to `True`.\n\nReturns:\n    A list of float values representing the current joint positions of the arm in the\n    following order: [shoulder_pitch, shoulder_roll, elbow_yaw, elbow_pitch, wrist_roll, wrist_pitch,\n    wrist_yaw].",
        "source_code": "ort FloatValue\nf",
        "return_type": "List[float]",
        "parameters": {
          "self": "Any",
          "degrees": "bool"
        }
      },
      {
        "name": "forward_kinematics",
        "signature": "(self, joints_positions: Optional[List[float]], degrees: bool) -> npt.NDArray[np.float64]",
        "docstring": "Compute the forward kinematics of the arm and return a 4x4 pose matrix.\n\nThe pose matrix is expressed in Reachy coordinate system.\n\nArgs:\n    joints_positions: A list of float values representing the positions of the joints\n        in the arm. If not provided, the current robot joints positions are used. Defaults to None.\n    degrees: Indicates whether the joint positions are in degrees or radians.\n        If `True`, the positions are in degrees; if `False`, in radians. Defaults to True.\n\nReturns:\n    A 4x4 pose matrix as a NumPy array, expressed in Reachy coordinate system.\n\nRaises:\n    ValueError: If `joints_positions` is provided and its length is not 7.\n    ValueError: If no solution is found for the given joint positions.",
        "source_code": "om pyquaternion import Quaternion\nfrom ",
        "return_type": "npt.NDArray[np.float64]",
        "parameters": {
          "self": "Any",
          "joints_positions": "Optional[List[float]]",
          "degrees": "bool"
        }
      },
      {
        "name": "inverse_kinematics",
        "signature": "(self, target: npt.NDArray[np.float64], q0: Optional[List[float]], degrees: bool) -> List[float]",
        "docstring": "Compute a joint configuration to reach a specified target pose for the arm end-effector.\n\nArgs:\n    target: A 4x4 homogeneous pose matrix representing the target pose in\n        Reachy coordinate system, provided as a NumPy array.\n    q0: An optional initial joint configuration for the arm. If provided, the\n        algorithm will use it as a starting point for finding a solution. Defaults to None.\n    degrees: Indicates whether the returned joint angles should be in degrees or radians.\n        If `True`, angles are in degrees; if `False`, in radians. Defaults to True.\n    round: Number of decimal places to round the computed joint angles to before\n        returning. If None, no rounding is performed. Defaults to None.\n\nReturns:\n    A list of joint angles representing the solution to reach the target pose, in the following order:\n        [shoulder_pitch, shoulder_roll, elbo_yaw, elbow_pitch, wrist.roll, wrist.pitch, wrist.yaw].\n\nRaises:\n    ValueError: If the target shape is not (4, 4).\n    ValueError: If the length of `q0` is not 7.\n    ValueError: If vectorized kinematics is attempted (unsupported).\n    ValueError: If no solution is found for the given target.",
        "source_code": "eachy2_sdk_api.arm_pb2 import Arm as Arm_proto\nfrom reachy2_s",
        "return_type": "List[float]",
        "parameters": {
          "self": "Any",
          "target": "npt.NDArray[np.float64]",
          "q0": "Optional[List[float]]",
          "degrees": "bool"
        }
      },
      {
        "name": "goto",
        "signature": "(self, target: List[float], duration: float, wait: bool, interpolation_mode: str, degrees: bool, q0: Optional[List[float]]) -> GoToId",
        "docstring": "",
        "source_code": "_api.arm_p",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "target": "List[float]",
          "duration": "float",
          "wait": "bool",
          "interpolation_mode": "str",
          "degrees": "bool",
          "q0": "Optional[List[float]]"
        }
      },
      {
        "name": "goto",
        "signature": "(self, target: npt.NDArray[np.float64], duration: float, wait: bool, interpolation_mode: str, degrees: bool, q0: Optional[List[float]]) -> GoToId",
        "docstring": "",
        "source_code": " import ( ",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "target": "npt.NDArray[np.float64]",
          "duration": "float",
          "wait": "bool",
          "interpolation_mode": "str",
          "degrees": "bool",
          "q0": "Optional[List[float]]"
        }
      },
      {
        "name": "goto",
        "signature": "(self, target: Any, duration: float, wait: bool, interpolation_mode: str, degrees: bool, q0: Optional[List[float]]) -> GoToId",
        "docstring": "Move the arm to a specified target position, either in joint space or Cartesian space.\n\nThis function allows the arm to move to a specified target using either:\n- A list of 7 joint positions, or\n- A 4x4 pose matrix representing the desired end-effector position.\n\nThe function also supports an optional initial configuration `q0` for\ncomputing the inverse kinematics solution when the target is in Cartesian space.\n\nArgs:\n    target: The target position. It can either be a list of 7 joint values (for joint space)\n            or a 4x4 NumPy array (for Cartesian space).\n    duration: The time in seconds for the movement to be completed. Defaults to 2.\n    wait: If True, the function waits until the movement is completed before returning.\n            Defaults to False.\n    interpolation_mode: The interpolation method to be used. It can be either \"minimum_jerk\"\n            or \"linear\". Defaults to \"minimum_jerk\".\n    degrees: If True, the joint values in the `target` argument are treated as degrees.\n            Defaults to True.\n    q0: An optional list of 7 joint values representing the initial configuration\n            for inverse kinematics. Defaults to None.\n\nReturns:\n    GoToId: The unique GoToId identifier for the movement command.\n\nRaises:\n    TypeError: If the `target` is neither a list nor a pose matrix.\n    TypeError: If the `q0` is not a list.\n    ValueError: If the `target` list has a length other than 7, or the pose matrix is not\n        of shape (4, 4).\n    ValueError: If the `q0` list has a length other than 7.\n    ValueError: If the `duration` is set to 0.",
        "source_code": "# ArmLimits,; ArmTemperatures,\n    ArmCartesianGoal,\n    Ar",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "target": "Any",
          "duration": "float",
          "wait": "bool",
          "interpolation_mode": "str",
          "degrees": "bool",
          "q0": "Optional[List[float]]"
        }
      },
      {
        "name": "goto_posture",
        "signature": "(self, common_posture: str, duration: float, wait: bool, wait_for_goto_end: bool, interpolation_mode: str, open_gripper: bool) -> GoToId",
        "docstring": "Send all joints to standard positions with optional parameters for duration, waiting, and interpolation mode.\n\nArgs:\n    common_posture: The standard positions to which all joints will be sent.\n        It can be 'default' or 'elbow_90'. Defaults to 'default'.\n    duration: The time duration in seconds for the robot to move to the specified posture.\n        Defaults to 2.\n    wait: Determines whether the program should wait for the movement to finish before\n        returning. If set to `True`, the program waits for the movement to complete before continuing\n        execution. Defaults to `False`.\n    wait_for_goto_end: Specifies whether commands will be sent to a part immediately or\n        only after all previous commands in the queue have been executed. If set to `False`, the program\n        will cancel all executing moves and queues. Defaults to `True`.\n    interpolation_mode: The type of interpolation used when moving the arm's joints.\n        Can be 'minimum_jerk' or 'linear'. Defaults to 'minimum_jerk'.\n    open_gripper: If `True`, the gripper will open, if `False`, it stays in its current position.\n        Defaults to `False`.\n\nReturns:\n    A unique GoToId identifier for this specific movement.",
        "source_code": "achy2_sdk_api.arm_pb2_grpc import ArmSer",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "common_posture": "str",
          "duration": "float",
          "wait": "bool",
          "wait_for_goto_end": "bool",
          "interpolation_mode": "str",
          "open_gripper": "bool"
        }
      },
      {
        "name": "get_default_posture_joints",
        "signature": "(self, common_posture: str) -> List[float]",
        "docstring": "Get the list of joint positions for default or elbow_90 poses.\n\nArgs:\n    common_posture: The name of the posture to retrieve. Can be \"default\" or \"elbow_90\".\n        Defaults to \"default\".\n\nReturns:\n    A list of joint positions in degrees for the specified posture.\n\nRaises:\n    ValueError: If `common_posture` is not \"default\" or \"elbow_90\".",
        "source_code": "iceStub\nfrom reachy2_sd",
        "return_type": "List[float]",
        "parameters": {
          "self": "Any",
          "common_posture": "str"
        }
      },
      {
        "name": "get_default_posture_matrix",
        "signature": "(self, common_posture: str) -> npt.NDArray[np.float64]",
        "docstring": "Get the 4x4 pose matrix in Reachy coordinate system for a default robot posture.\n\nArgs:\n    common_posture: The posture to retrieve. Can be \"default\" or \"elbow_90\".\n        Defaults to \"default\".\n\nReturns:\n    The 4x4 homogeneous pose matrix for the specified posture in Reachy coordinate system.",
        "source_code": "_api.goto_pb",
        "return_type": "npt.NDArray[np.float64]",
        "parameters": {
          "self": "Any",
          "common_posture": "str"
        }
      },
      {
        "name": "get_translation_by",
        "signature": "(self, x: float, y: float, z: float, initial_pose: Optional[npt.NDArray[np.float64]], frame: str) -> npt.NDArray[np.float64]",
        "docstring": "Return a 4x4 matrix representing a pose translated by specified x, y, z values.\n\nThe translation is performed in either the robot or gripper coordinate system.\n\nArgs:\n    x: Translation along the x-axis in meters (forwards direction) to apply\n        to the pose matrix.\n    y: Translation along the y-axis in meters (left direction) to apply\n        to the pose matrix.\n    z: Translation along the z-axis in meters (upwards direction) to apply\n        to the pose matrix.\n    initial_pose: A 4x4 matrix representing the initial pose of the end-effector in Reachy coordinate system,\n        expressed as a NumPy array of type `np.float64`.\n        If not provided, the current pose of the arm is used. Defaults to `None`.\n    frame: The coordinate system in which the translation should be performed.\n        Can be either \"robot\" or \"gripper\". Defaults to \"robot\".\n\nReturns:\n    A 4x4 pose matrix, expressed in Reachy coordinate system,\n    translated by the specified x, y, z values from the initial pose.\n\nRaises:\n    ValueError: If the `frame` is not \"robot\" or \"gripper\".",
        "source_code": " import (\n    CartesianGoal,\n    CustomJointGoa",
        "return_type": "npt.NDArray[np.float64]",
        "parameters": {
          "self": "Any",
          "x": "float",
          "y": "float",
          "z": "float",
          "initial_pose": "Optional[npt.NDArray[np.float64]]",
          "frame": "str"
        }
      },
      {
        "name": "translate_by",
        "signature": "(self, x: float, y: float, z: float, duration: float, wait: bool, frame: str, interpolation_mode: str) -> GoToId",
        "docstring": "Create a translation movement for the arm's end effector.\n\nThe movement is based on the last sent position or the current position.\n\nArgs:\n    x: Translation along the x-axis in meters (forwards direction) to apply\n        to the pose matrix.\n    y: Translation along the y-axis in meters (left direction) to apply\n        to the pose matrix.\n    z: Translation along the z-axis in meters (vertical direction) to apply\n        to the pose matrix.\n    duration: Time duration in seconds for the translation movement to be completed.\n        Defaults to 2.\n    wait: Determines whether the program should wait for the movement to finish before\n        returning. If set to `True`, the program waits for the movement to complete before continuing\n        execution. Defaults to `False`.\n    frame: The coordinate system in which the translation should be performed.\n        Can be \"robot\" or \"gripper\". Defaults to \"robot\".\n    interpolation_mode: The type of interpolation to be used when moving the arm's\n        joints. Can be 'minimum_jerk' or 'linear'. Defaults to 'minimum_jerk'.\n\nReturns:\n    The GoToId of the movement command, created using the `goto_from_matrix` method with the\n    translated pose computed in the specified frame.\n\nRaises:\n    ValueError: If the `frame` is not \"robot\" or \"gripper\".",
        "source_code": ",\n    GoToId,\n    GoToRequest,\n    JointsGoal,\n)\nfrom r",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "x": "float",
          "y": "float",
          "z": "float",
          "duration": "float",
          "wait": "bool",
          "frame": "str",
          "interpolation_mode": "str"
        }
      },
      {
        "name": "get_rotation_by",
        "signature": "(self, roll: float, pitch: float, yaw: float, initial_pose: Optional[npt.NDArray[np.float64]], degrees: bool, frame: str) -> npt.NDArray[np.float64]",
        "docstring": "Calculate a new pose matrix by rotating an initial pose matrix by specified roll, pitch, and yaw angles.\n\nThe rotation is performed in either the robot or gripper coordinate system.\n\nArgs:\n    roll: Rotation around the x-axis in the Euler angles representation, specified\n        in radians or degrees (based on the `degrees` parameter).\n    pitch: Rotation around the y-axis in the Euler angles representation, specified\n        in radians or degrees (based on the `degrees` parameter).\n    yaw: Rotation around the z-axis in the Euler angles representation, specified\n        in radians or degrees (based on the `degrees` parameter).\n    initial_pose: A 4x4 matrix representing the initial\n        pose of the end-effector, expressed as a NumPy array of type `np.float64`. If not provided,\n        the current pose of the arm is used. Defaults to `None`.\n    degrees: Specifies whether the rotation angles are provided in degrees. If set to\n        `True`, the angles are interpreted as degrees. Defaults to `True`.\n    frame: The coordinate system in which the rotation should be performed. Can be\n        \"robot\" or \"gripper\". Defaults to \"robot\".\n\nReturns:\n    A 4x4 pose matrix, expressed in the Reachy coordinate system, rotated\n    by the specified roll, pitch, and yaw angles from the initial pose, in the specified frame.\n\nRaises:\n    ValueError: If the `frame` is not \"robot\" or \"gripper\".",
        "source_code": "achy2_sdk_api.goto_pb2_grpc import GoToServiceStub\nfro",
        "return_type": "npt.NDArray[np.float64]",
        "parameters": {
          "self": "Any",
          "roll": "float",
          "pitch": "float",
          "yaw": "float",
          "initial_pose": "Optional[npt.NDArray[np.float64]]",
          "degrees": "bool",
          "frame": "str"
        }
      },
      {
        "name": "rotate_by",
        "signature": "(self, roll: float, pitch: float, yaw: float, duration: float, wait: bool, degrees: bool, frame: str, interpolation_mode: str) -> GoToId",
        "docstring": "Create a rotation movement for the arm's end effector based on the specified roll, pitch, and yaw angles.\n\nThe rotation is performed in either the robot or gripper frame.\n\nArgs:\n    roll: Rotation around the x-axis in the Euler angles representation, specified\n        in radians or degrees (based on the `degrees` parameter).\n    pitch: Rotation around the y-axis in the Euler angles representation, specified\n        in radians or degrees (based on the `degrees` parameter).\n    yaw: Rotation around the z-axis in the Euler angles representation, specified\n        in radians or degrees (based on the `degrees` parameter).\n    duration: Time duration in seconds for the rotation movement to be completed.\n        Defaults to 2.\n    wait: Determines whether the program should wait for the movement to finish before\n        returning. If set to `True`, the program waits for the movement to complete before continuing\n        execution. Defaults to `False`.\n    degrees: Specifies whether the rotation angles are provided in degrees. If set to\n        `True`, the angles are interpreted as degrees. Defaults to `True`.\n    frame: The coordinate system in which the rotation should be performed. Can be\n        \"robot\" or \"gripper\". Defaults to \"robot\".\n    interpolation_mode: The type of interpolation to be used when moving the arm's\n        joints. Can be 'minimum_jerk' or 'linear'. Defaults to 'minimum_jerk'.\n\nReturns:\n    The GoToId of the movement command, created by calling the `goto_from_matrix` method with\n    the rotated pose computed in the specified frame.\n\nRaises:\n    ValueError: If the `frame` is not \"robot\" or \"gripper\".",
        "source_code": " reachy2_sdk_api.hand_pb2 import Hand as HandState\nfrom reach",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "roll": "float",
          "pitch": "float",
          "yaw": "float",
          "duration": "float",
          "wait": "bool",
          "degrees": "bool",
          "frame": "str",
          "interpolation_mode": "str"
        }
      },
      {
        "name": "send_cartesian_interpolation",
        "signature": "(self, target: npt.NDArray[np.float64], duration: float, arc_direction: Optional[str], elliptic_radius: Optional[float], interpolation_frequency: float, precision_distance_xyz: float) -> None",
        "docstring": "Perform Cartesian interpolation and move the arm towards a target pose.\n\nThe function uses linear or elliptical interpolation for translation to reach or get close\nto the specified target pose.\n\nArgs:\n    target: A 4x4 homogeneous pose matrix representing the desired\n        position and orientation in the Reachy coordinate system, provided as a NumPy array.\n    duration: The expected time in seconds for the arm to reach the target position\n        from its current position. Defaults to 2.\n    arc_direction: The direction for elliptic interpolation when moving\n        the arm towards the target pose. Can be 'above', 'below', 'right', 'left', 'front',\n        or 'back'. If not specified, a linear interpolation is computed.\n    elliptic_radius: The second radius of the computed ellipse for elliptical\n        interpolation. The first radius is the distance between the current pose and the\n        target pose. If not specified, a circular interpolation is used.\n    interpolation_frequency: The number of intermediate points used to interpolate\n        the movement in Cartesian space between the initial and target poses. Defaults to 120.\n    precision_distance_xyz: The maximum allowed distance in meters in the XYZ space between\n        the current end-effector position and the target position. If the end-effector is\n        further than this distance from the target after the movement, the movement is repeated\n        until the precision is met. Defaults to 0.003.\n\nRaises:\n    TypeError: If the target is not a NumPy matrix.\n    ValueError: If the target shape is not (4, 4).\n    ValueError: If the duration is set to 0.",
        "source_code": "nd_pb2 import Hand as Hand_proto\nfrom reachy2_sdk_api.kinematics_pb2 import Matrix4x4\n\n",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "target": "npt.NDArray[np.float64]",
          "duration": "float",
          "arc_direction": "Optional[str]",
          "elliptic_radius": "Optional[float]",
          "interpolation_frequency": "float",
          "precision_distance_xyz": "float"
        }
      },
      {
        "name": "send_goal_positions",
        "signature": "(self, check_positions: bool) -> None",
        "docstring": "Send goal positions to the gripper and actuators if the parts are on.\n\nThe function checks if the gripper and actuators are active before sending the goal positions.\n\nArgs :\n    check_positions: A boolean indicating whether to check the positions after sending the command.\n        Defaults to True.",
        "source_code": "se_matrix,\n    g",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "check_positions": "bool"
        }
      }
    ],
    "source": "reachy2_sdk.parts.arm.Arm"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.parts.head",
    "docstring": "Reachy Head module.\n\nHandles all specific methods to a Head.",
    "source": "parts.head"
  },
  {
    "type": "class",
    "name": "Head",
    "module": "reachy2_sdk.parts.head",
    "docstring": "Head class for controlling the head of Reachy.\n\nThe `Head` class manages the neck actuator and provides utilities for controlling the orientation\nof the head, such as moving to a specific posture or looking at a Cartesian point in Reachy's\ncoordinate system.\n\nAttributes:\n    neck: An instance of `Orbita3d` representing the neck actuator of the head.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, head_msg: Head_proto, initial_state: HeadState, grpc_channel: grpc.Channel, goto_stub: GoToServiceStub) -> None",
        "docstring": "Initialize the Head component with its actuators.\n\nSets up the necessary attributes and configuration for the head, including the gRPC\nstubs and initial state.\n\nArgs:\n    head_msg: The Head_proto object containing the configuration details for the head.\n    initial_state: The initial state of the head, represented as a HeadState object.\n    grpc_channel: The gRPC channel used to communicate with the head's gRPC service.\n    goto_stub: The GoToServiceStub used to handle goto-based movements for the head.",
        "source_code": "ods to a Head.\n\"\"\"\n\nfrom ",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "head_msg": "Head_proto",
          "initial_state": "HeadState",
          "grpc_channel": "grpc.Channel",
          "goto_stub": "GoToServiceStub"
        }
      },
      {
        "name": "neck",
        "signature": "(self) -> Orbita3d",
        "docstring": "Get the neck actuator of the head.",
        "source_code": "ion",
        "return_type": "Orbita3d",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_current_orientation",
        "signature": "(self) -> pyQuat",
        "docstring": "Get the current orientation of the head.\n\nReturns:\n    The orientation of the head as a quaternion (w, x, y, z).",
        "source_code": "l, overl",
        "return_type": "pyQuat",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_current_positions",
        "signature": "(self, degrees: bool) -> List[float]",
        "docstring": "Return the current joint positions of the neck.\n\nReturns:\n    A list of the current neck joint positions in the order [roll, pitch, yaw].",
        "source_code": "ad\n\nimport g",
        "return_type": "List[float]",
        "parameters": {
          "self": "Any",
          "degrees": "bool"
        }
      },
      {
        "name": "goto",
        "signature": "(self, target: List[float], duration: float, wait: bool, interpolation_mode: str, degrees: bool) -> GoToId",
        "docstring": "",
        "source_code": "c\nimport ",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "target": "List[float]",
          "duration": "float",
          "wait": "bool",
          "interpolation_mode": "str",
          "degrees": "bool"
        }
      },
      {
        "name": "goto",
        "signature": "(self, target: pyQuat, duration: float, wait: bool, interpolation_mode: str, degrees: bool) -> GoToId",
        "docstring": "",
        "source_code": "mpy as np",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "target": "pyQuat",
          "duration": "float",
          "wait": "bool",
          "interpolation_mode": "str",
          "degrees": "bool"
        }
      },
      {
        "name": "goto",
        "signature": "(self, target: Any, duration: float, wait: bool, interpolation_mode: str, degrees: bool) -> GoToId",
        "docstring": "Send the neck to a specified orientation.\n\nThis method moves the neck either to a given roll-pitch-yaw (RPY) position or to a quaternion orientation.\n\nArgs:\n    target (Any): The desired orientation for the neck. Can either be:\n        - A list of three floats [roll, pitch, yaw] representing the RPY orientation (in degrees if `degrees=True`).\n        - A pyQuat object representing a quaternion.\n    duration (float, optional): Time in seconds for the movement. Defaults to 2.0.\n    wait (bool, optional): Whether to wait for the movement to complete before returning. Defaults to False.\n    interpolation_mode (str, optional): The type of interpolation to be used for the movement.\n                                        Can be \"minimum_jerk\" or other modes. Defaults to \"minimum_jerk\".\n    degrees (bool, optional): Specifies if the RPY values in `target` are in degrees. Defaults to True.\n\nRaises:\n    TypeError : If the input type for `target` is invalid\n    ValueError: If the `duration` is set to 0.\n\nReturns:\n    GoToId: The unique identifier for the movement command.",
        "source_code": "from google.protobuf.wrappers_pb2 import FloatValue\nfrom pyquaternion i",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "target": "Any",
          "duration": "float",
          "wait": "bool",
          "interpolation_mode": "str",
          "degrees": "bool"
        }
      },
      {
        "name": "look_at",
        "signature": "(self, x: float, y: float, z: float, duration: float, wait: bool, interpolation_mode: str) -> GoToId",
        "docstring": "Compute and send a neck position to look at a specified point in Reachy's Cartesian space (torso frame).\n\nThe (x, y, z) coordinates are expressed in meters, where x is forward, y is left, and z is upward.\n\nArgs:\n    x: The x-coordinate of the target point.\n    y: The y-coordinate of the target point.\n    z: The z-coordinate of the target point.\n    duration: The time in seconds for the head to look at the point. Defaults to 2.0.\n    wait: Whether to wait for the movement to complete before returning. Defaults to False.\n    interpolation_mode: The interpolation mode for the movement, either \"minimum_jerk\" or \"linear\".\n        Defaults to \"minimum_jerk\".\n\nReturns:\n    The unique GoToId associated with the movement command.\n\nRaises:\n    ValueError: If the duration is set to 0.",
        "source_code": "artesianGoal,\n    CustomJointGoal,\n    GoToId",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "x": "float",
          "y": "float",
          "z": "float",
          "duration": "float",
          "wait": "bool",
          "interpolation_mode": "str"
        }
      },
      {
        "name": "rotate_by",
        "signature": "(self, roll: float, pitch: float, yaw: float, duration: float, wait: bool, degrees: bool, frame: str, interpolation_mode: str) -> GoToId",
        "docstring": "Rotate the neck by the specified angles.\n\nArgs:\n    roll: The angle in degrees to rotate around the x-axis (roll). Defaults to 0.\n    pitch: The angle in degrees to rotate around the y-axis (pitch). Defaults to 0.\n    yaw: The angle in degrees to rotate around the z-axis (yaw). Defaults to 0.\n    duration: The time in seconds for the neck to reach the target posture. Defaults to 2.\n    wait: Whether to wait for the movement to complete before returning. Defaults to False.\n    degrees: Whether the angles are provided in degrees. If True, the angles will be converted to radians.\n        Defaults to True.\n    frame: The frame of reference for the rotation. Can be either \"robot\" or \"head\". Defaults to \"robot\".\n    interpolation_mode: The interpolation mode for the movement, either \"minimum_jerk\" or \"linear\".\n        Defaults to \"minimum_jerk\".\n\n\nRaises:\n    ValueError: If the frame is not \"robot\" or \"head\".\n    ValueError: If the duration is set to 0.\n    ValueError: If the interpolation mode is not \"minimum_jerk\" or \"linear\".",
        "source_code": "\n    GoToRequest,\n    JointsGoal,\n)\nfrom reachy2_sdk_api.goto_pb2_",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "roll": "float",
          "pitch": "float",
          "yaw": "float",
          "duration": "float",
          "wait": "bool",
          "degrees": "bool",
          "frame": "str",
          "interpolation_mode": "str"
        }
      },
      {
        "name": "goto_posture",
        "signature": "(self, common_posture: str, duration: float, wait: bool, wait_for_goto_end: bool, interpolation_mode: str) -> GoToId",
        "docstring": "Send all neck joints to standard positions within the specified duration.\n\nThe default posture sets the neck joints to [0, -10, 0] (roll, pitch, yaw).\n\nArgs:\n    common_posture: The standard positions to which all joints will be sent.\n        It can be 'default' or 'elbow_90'. Defaults to 'default'.\n    duration: The time in seconds for the neck to reach the target posture. Defaults to 2.\n    wait: Whether to wait for the movement to complete before returning. Defaults to False.\n    wait_for_goto_end: Whether to wait for all previous goto commands to finish before executing\n        the current command. If False, it cancels all ongoing commands. Defaults to True.\n    interpolation_mode: The interpolation mode for the movement, either \"minimum_jerk\" or \"linear\".\n        Defaults to \"minimum_jerk\".\n\nReturns:\n    The unique GoToId associated with the movement command.\n\nRaises:\n    ValueError: If the neck is off and the command cannot be sent.",
        "source_code": "rpc import GoToServiceStub\nfrom rea",
        "return_type": "GoToId",
        "parameters": {
          "self": "Any",
          "common_posture": "str",
          "duration": "float",
          "wait": "bool",
          "wait_for_goto_end": "bool",
          "interpolation_mode": "str"
        }
      },
      {
        "name": "send_goal_positions",
        "signature": "(self, check_positions: bool) -> None",
        "docstring": "Send goal positions to the head's joints.\n\nIf goal positions have been specified for any joint of the head, sends them to the robot.\n\nArgs :\n    check_positions: A boolean indicating whether to check the positions after sending the command.\n        Defaults to True.",
        "source_code": "hy2_sdk_api.he",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "check_positions": "bool"
        }
      }
    ],
    "source": "reachy2_sdk.parts.head.Head"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.parts.hand",
    "docstring": "Reachy Hand module.\n\nHandles all specific method to a Hand.",
    "source": "parts.hand"
  },
  {
    "type": "class",
    "name": "Hand",
    "module": "reachy2_sdk.parts.hand",
    "docstring": "Class for controlling the Reachy's hand.\n\nThe `Hand` class provides methods to control the gripper of Reachy, including opening and closing\nthe hand, setting the goal position, and checking the hand's state. It also manages the hand's\ncompliance status (whether it is stiff or free).\n\nAttributes:\n    opening: The opening of the hand as a percentage (0-100), rounded to two decimal places.\n    present_position: The current position of the hand in degrees.\n    goal_position: The target goal position of the hand in degrees.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, hand_msg: Hand_proto, initial_state: HandState, grpc_channel: grpc.Channel) -> None",
        "docstring": "Initialize the Hand component.\n\nSets up the necessary attributes and configuration for the hand, including the gRPC\nstub and initial state.\n\nArgs:\n    hand_msg: The Hand_proto object containing the configuration details for the hand.\n    initial_state: The initial state of the hand, represented as a HandState object.\n    grpc_channel: The gRPC channel used to communicate with the hand's gRPC service.",
        "source_code": "ecific method to a Hand.",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "hand_msg": "Hand_proto",
          "initial_state": "HandState",
          "grpc_channel": "grpc.Channel"
        }
      },
      {
        "name": "opening",
        "signature": "(self) -> float",
        "docstring": "Get the opening of the hand as a percentage.\n\nReturns:\n    The hand opening as a percentage (0-100), rounded to two decimal places.",
        "source_code": "que\nfro",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "present_position",
        "signature": "(self) -> float",
        "docstring": "Get the current position of the hand.\n\nReturns:\n    The present position of the hand in degrees.",
        "source_code": "typing ",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "goal_position",
        "signature": "(self) -> float",
        "docstring": "Get the goal position of the hand.\n\nReturns:\n    The goal position of the hand in degrees.",
        "source_code": "port De",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "goal_position",
        "signature": "(self, value: float | int) -> None",
        "docstring": "Set the goal position for the hand.\n\nArgs:\n    value: The goal position to set, specified as a float or int.\n\nRaises:\n    TypeError: If the provided value is not a float or int.",
        "source_code": "e, Optional\n\n",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "value": "float | int"
        }
      },
      {
        "name": "is_on",
        "signature": "(self) -> bool",
        "docstring": "Check if the hand is stiff.\n\nReturns:\n    `True` if the hand is on (not compliant), `False` otherwise.",
        "source_code": "mport g",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_off",
        "signature": "(self) -> bool",
        "docstring": "Check if the hand is compliant.\n\nReturns:\n    `True` if the hand is off (compliant), `False` otherwise.",
        "source_code": "pc\nimpo",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_moving",
        "signature": "(self) -> bool",
        "docstring": "Check if the hand is currently moving.\n\nReturns:\n    `True` if the gripper is moving, `False` otherwise.",
        "source_code": "t numpy",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "get_current_opening",
        "signature": "(self) -> float",
        "docstring": "Get the current opening of the hand.\n\nReturns:\n    The current opening of the hand as a percentage (0-100).",
        "source_code": "protobu",
        "return_type": "float",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "open",
        "signature": "(self) -> None",
        "docstring": "Open the hand.\n\nRaises:\n    RuntimeError: If the gripper is off and the open request cannot be sent.",
        "source_code": ".wrappers_",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "close",
        "signature": "(self) -> None",
        "docstring": "Close the hand.\n\nRaises:\n    RuntimeError: If the gripper is off and the close request cannot be sent.",
        "source_code": "b2 import ",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "set_opening",
        "signature": "(self, percentage: float) -> None",
        "docstring": "Set the opening value for the hand.\n\nArgs:\n    percentage: The desired opening percentage of the hand, ranging from 0 to 100.\n\nRaises:\n    ValueError: If the percentage is not between 0 and 100.\n    RuntimeError: If the gripper is off and the opening value cannot be set.",
        "source_code": "loatValue\nfrom reachy2_s",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "percentage": "float"
        }
      },
      {
        "name": "send_goal_positions",
        "signature": "(self, check_positions: bool) -> None",
        "docstring": "Send the goal position to the hand actuator.\n\nIf any goal position has been specified to the gripper, sends them to the robot.\nIf the hand is off, the command is not sent.\n\nArgs :\n    check_positions: A boolean indicating whether to check the positions after sending the command.\n        Defaults to True.",
        "source_code": "k_api.hand_pb2 import Ha",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "check_positions": "bool"
        }
      }
    ],
    "source": "reachy2_sdk.parts.hand.Hand"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.parts.part",
    "docstring": "Reachy Part module.\n\nHandles all specific methods commmon to all Reachy parts (Arm, Head, Hand or MobileBase).",
    "source": "parts.part"
  },
  {
    "type": "class",
    "name": "Part",
    "module": "reachy2_sdk.parts.part",
    "docstring": "The Part class serves as an abstract base class representing parts of a robot, such as Arm, Hand, Head, or MobileBase.\n\nThis class provides a common interface for managing robot components, including turning them on or off, checking their\nstatus, and updating their states. The class is intended to be subclassed to implement specific behaviors for different\ntypes of robot parts.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, proto_msg: Arm_proto | Head_proto | Hand_proto | MobileBase_proto, grpc_channel: grpc.Channel, stub: ArmServiceStub | HeadServiceStub | HandServiceStub | MobileBaseUtilityServiceStub) -> None",
        "docstring": "Initialize the Part with common attributes for gRPC communication.\n\nThis sets up the communication channel and service stubs for the specified part,\nconfigures the part's unique identifier. It provides the foundation for specific parts of the robot\n(Arm, Head, Hand, MobileBase) to be derived from this class.\n\nArgs:\n    proto_msg: The protobuf message containing configuration details for the part\n        (Arm, Head, Hand, or MobileBase).\n    grpc_channel: The gRPC channel used to communicate with the service.\n    stub: The service stub for the gRPC communication, which could be for Arm, Head,\n        Hand, or MobileBase.",
        "source_code": "l specific methods commmo",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "proto_msg": "Arm_proto | Head_proto | Hand_proto | MobileBase_proto",
          "grpc_channel": "grpc.Channel",
          "stub": "ArmServiceStub | HeadServiceStub | HandServiceStub | MobileBaseUtilityServiceStub"
        }
      },
      {
        "name": "turn_on",
        "signature": "(self) -> None",
        "docstring": "Turn on the part.\n\nThis method sets the speed limits to a low value, turns on all motors of the part, and then restores the speed limits\nto maximum. It waits for a brief period to ensure the operation is complete.",
        "source_code": " to all Reac",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "turn_off",
        "signature": "(self) -> None",
        "docstring": "Turn off the part.\n\nThis method turns off all motors of the part and waits for a brief period to ensure the operation is complete.",
        "source_code": "y parts",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_on",
        "signature": "(self) -> bool",
        "docstring": "Check if all actuators of the part are currently on.\n\nReturns:\n    True if all actuators are on, otherwise False.",
        "source_code": "ad, Hand o",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "is_off",
        "signature": "(self) -> bool",
        "docstring": "Check if all actuators of the part are currently off.\n\nReturns:\n    True if all actuators are off, otherwise False.",
        "source_code": " MobileBas",
        "return_type": "bool",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "audit",
        "signature": "(self) -> Dict[str, str]",
        "docstring": "Get the audit status of all actuators of the part.\n\nReturns:\n    A dictionary where each key is the name of an actuator and the value is its audit status.\n    If an error is detected in any actuator, a warning is logged. Otherwise, an informational\n    message indicating no errors is logged.",
        "source_code": "m abc import ABC, ",
        "return_type": "Dict[str, str]",
        "parameters": {
          "self": "Any"
        }
      }
    ],
    "source": "reachy2_sdk.parts.part.Part"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.media.__init__",
    "docstring": "Media module.\n\nThis module provides access to Reachy's cameras, microphones and speakers.",
    "source": "media.__init__"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.media.camera",
    "docstring": "Reachy Camera module.\n\nDefine the RGB Camera of Reachy's head (Teleop) and the RGBD Camera of its torso (Depth).\nProvide access to the frames (color, depth, disparity) and the camera parameters.",
    "source": "media.camera"
  },
  {
    "type": "class",
    "name": "CameraView",
    "module": "reachy2_sdk.media.camera",
    "docstring": "Enumeration for different camera views.\n\nThe `CameraView` enum provides options for specifying the view from which\nto capture images or video frames. For monocular cameras, LEFT is used as default.",
    "methods": [],
    "source": "reachy2_sdk.media.camera.CameraView"
  },
  {
    "type": "class",
    "name": "CameraType",
    "module": "reachy2_sdk.media.camera",
    "docstring": "Camera names defined in pollen-vision.",
    "methods": [],
    "source": "reachy2_sdk.media.camera.CameraType"
  },
  {
    "type": "class",
    "name": "Camera",
    "module": "reachy2_sdk.media.camera",
    "docstring": "Camera class represents an RGB camera on the robot.\n\nThe Camera class is primarily used for teleoperation cameras but can also be\nutilized for the RGB component of the RGB-D torso camera. It provides access\nto camera frames and parameters such as intrinsic, extrinsic matrices, and\ndistortion coefficients. Additionally, it allows for converting pixel coordinates\nto world coordinates.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, cam_info: CameraFeatures, video_stub: VideoServiceStub) -> None",
        "docstring": "Initialize a Camera instance.\n\nThis constructor sets up a camera instance by storing the camera's\ninformation and gRPC video stub for accessing camera-related services.\n\nArgs:\n    cam_info: An instance of `CameraFeatures` containing the camera's\n        details, such as its name, capabilities, and settings.\n    video_stub: A `VideoServiceStub` for making gRPC calls to the video\n        service, enabling access to camera frames, parameters, and other\n        camera-related functionality.",
        "source_code": "of Reachy's head",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "cam_info": "CameraFeatures",
          "video_stub": "VideoServiceStub"
        }
      },
      {
        "name": "get_frame",
        "signature": "(self, view: CameraView) -> Optional[Tuple[npt.NDArray[np.uint8], int]]",
        "docstring": "Retrieve an RGB frame from the camera.\n\nArgs:\n    view: The camera view to retrieve the frame from. Default is CameraView.LEFT.\n\nReturns:\n    A tuple containing the frame as a NumPy array in OpenCV format and the timestamp in nanoseconds.\n    Returns None if no frame is retrieved.",
        "source_code": "(Teleop) and the ",
        "return_type": "Optional[Tuple[npt.NDArray[np.uint8], int]]",
        "parameters": {
          "self": "Any",
          "view": "CameraView"
        }
      },
      {
        "name": "get_compressed_frame",
        "signature": "(self, view: CameraView) -> Optional[Tuple[bytes, int]]",
        "docstring": "Retrieve an RGB frame in a JPEG format from the camera.\n\nArgs:\n    view: The camera view to retrieve the frame from. Default is CameraView.LEFT.\n\nReturns:\n    A bytes array containing the jpeg frame and the timestamp in nanoseconds.\n    Returns None if no frame is retrieved.",
        "source_code": "GBD Camera of i",
        "return_type": "Optional[Tuple[bytes, int]]",
        "parameters": {
          "self": "Any",
          "view": "CameraView"
        }
      },
      {
        "name": "get_parameters",
        "signature": "(self, view: CameraView) -> Optional[Tuple[int, int, str, npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]]",
        "docstring": "Retrieve camera parameters including intrinsic matrix.\n\nArgs:\n    view: The camera view for which parameters should be retrieved. Default is CameraView.LEFT.\n\nReturns:\n    A tuple containing height, width, distortion model, distortion coefficients, intrinsic matrix,\n    rotation matrix, and projection matrix. Returns None if no parameters are retrieved.",
        "source_code": "s torso (Depth).\nProvide ",
        "return_type": "Optional[Tuple[int, int, str, npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]]",
        "parameters": {
          "self": "Any",
          "view": "CameraView"
        }
      },
      {
        "name": "get_extrinsics",
        "signature": "(self, view: CameraView) -> Optional[npt.NDArray[np.float64]]",
        "docstring": "Retrieve the 4x4 extrinsic matrix of the camera.\n\nArgs:\n    view: The camera view for which the extrinsic matrix should be retrieved. Default is CameraView.LEFT.\n\nReturns:\n    The extrinsic matrix as a NumPy array. Returns None if no matrix is retrieved.",
        "source_code": "ccess to the f",
        "return_type": "Optional[npt.NDArray[np.float64]]",
        "parameters": {
          "self": "Any",
          "view": "CameraView"
        }
      },
      {
        "name": "pixel_to_world",
        "signature": "(self, u: int, v: int, z_c: float, view: CameraView) -> Optional[npt.NDArray[np.float64]]",
        "docstring": "Convert pixel coordinates to XYZ coordinate in Reachy coordinate system.\n\nArgs:\n    u: The x-coordinate (pixel) in the camera view (horizontal axis, left-to-right).\n    v: The y-coordinate (pixel) in the camera view (vertical axis, top-to-bottom).\n    z_c: The depth value in meters at the given pixel. Default is 1.0.\n    view: The camera view to use for the conversion. Default is CameraView.LEFT.\n\nReturns:\n    A NumPy array containing the [X, Y, Z] world coordinates in meters. Returns None if the conversion fails.",
        "source_code": "ames (color, depth, disparity) and the ca",
        "return_type": "Optional[npt.NDArray[np.float64]]",
        "parameters": {
          "self": "Any",
          "u": "int",
          "v": "int",
          "z_c": "float",
          "view": "CameraView"
        }
      }
    ],
    "source": "reachy2_sdk.media.camera.Camera"
  },
  {
    "type": "class",
    "name": "DepthCamera",
    "module": "reachy2_sdk.media.camera",
    "docstring": "DepthCamera class represents the depth component of the RGB-D torso camera.\n\nIt provides access to depth frames and extends the functionality\nof the Camera class, allowing users to retrieve depth information.",
    "methods": [
      {
        "name": "get_depth_frame",
        "signature": "(self, view: CameraView) -> Optional[Tuple[npt.NDArray[np.uint16], int]]",
        "docstring": "Retrieve a depth frame from the camera.\n\nArgs:\n    view: The camera view to retrieve the depth frame from. Default is CameraView.DEPTH.\n\nReturns:\n    A tuple containing the depth frame as a NumPy array in 16-bit format and the timestamp in nanoseconds.\n    Returns None if no frame is retrieved.",
        "source_code": "\"\n\nimport logging\nfro",
        "return_type": "Optional[Tuple[npt.NDArray[np.uint16], int]]",
        "parameters": {
          "self": "Any",
          "view": "CameraView"
        }
      }
    ],
    "source": "reachy2_sdk.media.camera.DepthCamera"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.media.camera_manager",
    "docstring": "Reachy Camera Manager module.\n\nInitialize the head and torso cameras if they are available.",
    "source": "media.camera_manager"
  },
  {
    "type": "class",
    "name": "CameraManager",
    "module": "reachy2_sdk.media.camera_manager",
    "docstring": "CameraManager class manages the available cameras on the robot.\n\nProvides access to the robot's cameras, including teleoperation and depth cameras.\nIt handles the initialization of cameras and offers methods to retrieve camera objects for use.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, host: str, port: int) -> None",
        "docstring": "Set up the camera manager module.\n\nThis initializes the gRPC channel for communicating with the camera service,\nsets up logging, and prepares the available cameras.\n\nArgs:\n    host: The host address for the gRPC service.\n    port: The port number for the gRPC service.",
        "source_code": "er module.\n\nInitial",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "host": "str",
          "port": "int"
        }
      },
      {
        "name": "initialize_cameras",
        "signature": "(self) -> None",
        "docstring": "Manually re-initialize cameras.\n\nThis method can be used to reinitialize the camera setup if changes occur\nor new cameras are connected.",
        "source_code": "s if th",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "teleop",
        "signature": "(self) -> Optional[Camera]",
        "docstring": "Retrieve the teleop camera.\n\nReturns:\n    The teleop Camera object if it is initialized; otherwise, logs an error\n    and returns None.",
        "source_code": " are availab",
        "return_type": "Optional[Camera]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "depth",
        "signature": "(self) -> Optional[DepthCamera]",
        "docstring": "Retrieve the depth camera.\n\nReturns:\n    The DepthCamera object if it is initialized; otherwise, logs an error\n    and returns None.",
        "source_code": ".\n\"\"\"\n\nimpor",
        "return_type": "Optional[DepthCamera]",
        "parameters": {
          "self": "Any"
        }
      }
    ],
    "source": "reachy2_sdk.media.camera_manager.CameraManager"
  },
  {
    "type": "module",
    "name": "reachy2_sdk.media.audio",
    "docstring": "Reachy Audio module.\n\nEnable access to the microphones and speaker.",
    "source": "media.audio"
  },
  {
    "type": "class",
    "name": "Audio",
    "module": "reachy2_sdk.media.audio",
    "docstring": "Audio class manages the microhpones and speaker on the robot.\n\nIt allows to play audio files, and record audio. Please note that the audio files are stored in a\ntemporary folder on the robot and are deleted when the robot is turned off.",
    "methods": [
      {
        "name": "__init__",
        "signature": "(self, host: str, port: int) -> None",
        "docstring": "Set up the audio module.\n\nThis initializes the gRPC channel for communicating with the audio service.\n\nArgs:\n    host: The host address for the gRPC service.\n    port: The port number for the gRPC service.",
        "source_code": "\n\nEnable acces",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "host": "str",
          "port": "int"
        }
      },
      {
        "name": "upload_audio_file",
        "signature": "(self, path: str) -> bool",
        "docstring": "Upload an audio file to the robot.\n\nThis method uploads an audio file to the robot. The audio file is stored in a temporary folder on the robot\nand is deleted when the robot is turned off.\n\nArgs:\n    path: The path to the audio file to upload.",
        "source_code": "rophones and speaker.\n\"\"\"\n\nimport lo",
        "return_type": "bool",
        "parameters": {
          "self": "Any",
          "path": "str"
        }
      },
      {
        "name": "download_audio_file",
        "signature": "(self, name: str, path: str) -> bool",
        "docstring": "Download an audio file from the robot.\n\nArgs:\n    name: The name of the audio file to download.\n    path: The folder to save the downloaded audio file.",
        "source_code": "ging\nimport os\nfrom io im",
        "return_type": "bool",
        "parameters": {
          "self": "Any",
          "name": "str",
          "path": "str"
        }
      },
      {
        "name": "get_audio_files",
        "signature": "(self) -> List[str]",
        "docstring": "Get audio files from the robot.\n\nThis method retrieves the list of audio files stored on the robot.",
        "source_code": "ort Byte",
        "return_type": "List[str]",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "remove_audio_file",
        "signature": "(self, name: str) -> bool",
        "docstring": "Remove an audio file from the robot.\n\nThis method removes an audio file from the robot.\n\nArgs:\n    name: The name of the audio file to remove.",
        "source_code": "IO\nfrom typing",
        "return_type": "bool",
        "parameters": {
          "self": "Any",
          "name": "str"
        }
      },
      {
        "name": "play_audio_file",
        "signature": "(self, name: str) -> None",
        "docstring": "Play an audio file on the robot.\n\nThis method plays an audio file on the robot.\n\nArgs:\n    name: The name of the audio file to play.",
        "source_code": "import Ge",
        "return_type": "None",
        "parameters": {
          "self": "Any",
          "name": "str"
        }
      },
      {
        "name": "stop_playing",
        "signature": "(self) -> None",
        "docstring": "Stop playing audio on the robot.\n\nThis method stops the audio that is currently playing on the robot.",
        "source_code": "erator",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      },
      {
        "name": "record_audio",
        "signature": "(self, name: str, duration_secs: float) -> bool",
        "docstring": "Record audio on the robot.\n\nThis method records audio on the robot.\n\nArgs:\n    name: name of the audio file. The extension defines the encoding. Ony ogg is supported.\n    duration_secs: duration of the recording in seconds.",
        "source_code": " List\n\nimport g",
        "return_type": "bool",
        "parameters": {
          "self": "Any",
          "name": "str",
          "duration_secs": "float"
        }
      },
      {
        "name": "stop_recording",
        "signature": "(self) -> None",
        "docstring": "Stop recording audio on the robot.\n\nThis method stops the audio recording on the robot.",
        "source_code": "pc\nfro",
        "return_type": "None",
        "parameters": {
          "self": "Any"
        }
      }
    ],
    "source": "reachy2_sdk.media.audio.Audio"
  }
]